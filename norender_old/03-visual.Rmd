# Visualisering - ggplot2 dag 2 {#visual2}

```{r, echo=FALSE,fig.width = 3,fig.height=3}
# Bigger fig.width
library(jpeg)
library(knitr)
include_graphics("plots/ggplot2_logo.jpeg")
```

## Indledning og videoer

I dag udvider vi værktøjskassen af kommandoer i __ggplot2__ for at tillade større fleksibilitet og appel i dine visualiseringer. Jeg anbefaler at du ser videoerne inden undervisningstimerne og bruger notaterne som en slags reference samtidig at du arbejder med problemstillingerne.

### Læringsmålene

I skal være i stand til at:

* Arbejde fleksibelt med koordinat systemer - transformering, modificering og flipping af x- og y-aksen.
* Udvide brugen af farver og form.
* Tilføje tekst direkte på plottet med `geom_text()`.
* Bruge `facet_grid()` eller `facet_wrap()` til at lave yderligere opdeling af plots.
* Gemme dit færdigt plot i en fil.

<!-- * Gemmme det færdigt plot i en fil. -->

```{r}
library(ggplot2) #husk
```

### Video ressourcer

* Video 2: Koordinat systemer

Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/544201985
```{r,echo=FALSE}
library("vembedr")

embed_url("https://vimeo.com/544201985")
```

* Video 3: Farver og punkt former

Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/544218153
```{r,echo=FALSE}
library("vembedr")

embed_url("https://vimeo.com/544218153")
```

* Video 4: Labels - `geom_text()` og `geom_text_repel()`

Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/544226498
```{r,echo=FALSE}
library("vembedr")

embed_url("https://vimeo.com/544226498")
```


## Koordinat systemer

Her arbejder vi videre med koordinater i pakken __ggplot2__.

### Zoom på plottet (`coord_cartesian()`)

Man kan bruge funktionen `coord_cartesian()` til at zoome ind på et bestemt område i plottet. Indenfor `coord_cartesian()` angiver man `xlim()` og `ylim()`, som specificerer de øvre og nedre grænser langt henholdsvis x-aksen og y-aksen. Man kan også bruge `xlim()` og `ylim()` udenom `coord_cartesian()`, men i dette tilfælde bliver punkterne, som ikke kan ses i plottet (fordi deres koordinater ligger udenfor de angivne grænser), smidt væk, og så får man en advarsel. Med `coord_cartesian()` beholder man til gengæld samtlige data, og man får således ikke en advarsel.

Her ses vores oprindeligt scatter plot:

```{r,fig.width=5,fig.height=4}
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width,color = Species)) +
  geom_point() + 
  theme_minimal() 
```

Og her bruger vi funktionen `coord_cartesian()` med `xlim()` og `ylim()` indenfor til at zoome ind på et ønsket område på plottet.

```{r,fig.width=5,fig.height=4}
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width,color = Species)) +
  geom_point() + 
  coord_cartesian(xlim = c(4,6), ylim = c(2.2,4.5)) +
  theme_minimal() 
```

Hvis man har lyst til det kan man også zoome ud ved at bruge `expand_limits()`. For eksempel hvis jeg gerne vil have punkterne $x = 0$ og $y = 0$ (`c(0,0)`, eller "origin") med på plottet:

```{r,fig.width=5,fig.height=4}
ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width,col=Species)) +
  geom_point() + 
  expand_limits(x = 0, y = 0) +
  theme_minimal() 
```


### Transformering af akserne - log, sqrt osv (`scale_x_continuous`).

Nogle gange kan det være svært at visualisere nogle variabler på grund af deres fordeling. Er der mange outliers i variablen så er de fleste punkter samlede i et lille område i plottet. Transformering med `log` and `sqrt` på x-aksen og y-aksen. Vi kan bruge disse til at transformere skaleringen på akserne, så de data kan ses på en mere informativ måde.

```{r,fig.width=5,fig.height=4}
ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width,col=Species)) +
  geom_point(size=3) + 
  scale_x_continuous(trans = "log2") +
  scale_y_continuous(trans = "log2") +
  theme_minimal() 
```

Man kan også prøve  fk. "sqrt" i stedet for "log2". Formålet er, at hvis de data fordeler sig mere 'normalt', kan man nemmere visualiser det i et plot - en måde til at gøre der er ved at transformere de data med "sqrt" eller "log2".

### Flip coordinates (`coord_flip`)

Vi kan bruge `coord_flip()` til at spejler x-aksen på y-aksen og omvendt (det svarer til, at man drejer plottet ved 90 grader).

```{r,fig.width=5, fig.height=3, message=FALSE, warning=FALSE}
#Sepal.Group defineret som i går
iris$Sepal.Group <- ifelse(iris$Sepal.Length>mean(iris$Sepal.Length),"Long","Short")

ggplot(iris,aes(x=Species,fill=Sepal.Group)) + 
  geom_bar(stat="count",position="dodge",color="black") +
  coord_flip() +
  theme_minimal()
```

Man kan ændre på rækkefølgen af de tre `Species` ved at bruge funktionen `scale_x_discrete()` og angiver den nye rækkefølger med indstillingen `limits`:

```{r,fig.width=5, fig.height=3, message=FALSE, warning=FALSE}
ggplot(iris,aes(x=Species,fill=Sepal.Group)) + 
  geom_bar(stat="count",position="dodge",color="black") +
  coord_flip() +
  scale_x_discrete(limits = c("virginica", "versicolor","setosa")) +
  theme_minimal()
```

## Mere om farver og punkt former

Der er flere måder at specificere farver på i `ggplot2`. Man kan vælger den automatiske løsning, som er hurtigt (og effektiv i mange kontekster), eller kan man bruge den manuelt løsning (som kan tager lidt mere tid men er nyttige hvis man gerne vil lave et plot til at præsentere til andre.)

### Automatisk farver

Man kan automatisk specificere at vi gerne vil have forskellige farver, ligesom vi gjorde i går med `colour=Species` indenfor `aes()` i `ggplot` funktion.

```{r, fig.width=5,fig.height=5}
#automatisk løsning
ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width, colour=Species)) +
  geom_point() +
  theme_minimal() 
```

### Farver manuelt

Hvis man foretrækker at specificere sine egne farver, kan man det ved at benytte `scale_colour_manual`. 

```{r, fig.width=5,fig.height=4}
#manuelt løsning
ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width, colour=Species)) +
  scale_colour_manual(values=c("purple", "yellow","pink")) +
  geom_point() +
  theme_minimal() 
```

Man kan også bruge farver fra `RColorBrewer`-pakken. Pakken indeholder mange forskellige "colour palettes", som er gruppe af farver som passer godt med hinanden, så at man kan slipper for at vælge den bedste kombination af farver til deres plot. De palettes tager også i betragtning, fk. hvis man er farveblind, eller om man vil have en farvegradient eller et sæt diskrete farver som ikke ligner hinanden.

Der er andre pakke som også har andre colour palettes som man kan bruge, som jeg anbefaler at I tjekke ud på Google hvis interesseret.

```{r, fig.width=5,fig.height=4}
#install.packages("RColorBrewer")
library(RColorBrewer)

#manuelt løsning
ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width, colour=Species)) +
  scale_color_brewer(palette="Set1") +
  geom_point() +
  theme_minimal() 
```

Bemærk, at `scale_color_brewer()` eller `scale_color_maual()` sætte farver af punkt og linjer, mens i en boxplot eller barplot sammenhænge, ligesom man specificerede `fill=Species` indenfor `aes()`, bruger man  `scale_fill_manual()` eller `scale_fill_brewer()` i tilfældet af RColourBrewer.

```{r, fig.width=5,fig.height=4}
ggplot(iris,aes(x=Species,y=Sepal.Length,fill=Species)) + 
  geom_boxplot() +
  scale_fill_brewer(palette="Set2")  + 
  theme_minimal()
```


Her er en tabel over de fire funktioner. 

fuktion | beskrivelse
--- | ---
`scale_fill_manual(values=c("firebrick3","blue"))` | manuelle farver til boxplots og barplots osv.
`scale_color_maual(values=c("darkorchid","cyan4"))` | manulle farver til punkter og linjer osv.
`scale_fill_brewer(palette="Dark2")` | `RColourBrewer` løsning til boxplots/barplots/osv.
`scale_color_brewer(palette="Set1")` | `RColourBrewer` løsning til punkter og linjer osv.

Der er også andre, for eksempel for continuous scala kan man google efter `scale_fill_gradient`.

***Farver i RColourBrewer***

Bare som reference for de forskellige farver tilgængelige i pakken `RColourBrewer`.

![Mulige colour palettes tilgængelige i RColourBrewer](plots/rcolorbrewer.png)


### Punkt former

Ligesom man kan lave forskellige farver, kan man også lave forskellige punkt former.

Vi starter med den automatiske løsning ligesom vi gjorde med farver. Når det er en variable vi specificer, skal vi skrive indenfor aes(). Her, da `shape` er en parameter som er meget specifik til `geom_point`, her vælger vi at sætte den indenfor en ny `aes()` indenfor `geom_point()` i stedet for indenfor `ggplot()`. Husk, at i funktionen `ggplot()` specificerer vi globale ting som gælder for hele plot, og i funktionen `geom_pont()` ting som gælder kun for `geom_point()`.

```{r,fig.width=5,fig.height=4}
ggplot(data=iris, aes(x = Sepal.Length, y = Sepal.Width)) +
  scale_color_brewer(palette="Set2") +
  geom_point(aes(shape=Species)) + 
  theme_minimal()
```
Så har vi fået en kombination af båre forskellige farver og punkter til hver `Species`.

***Sætte punkte former manuelt***

Hvis vi ikke kan lide de tre punkt former vi få automatisk, kan vi ændre dem ved at bruge `scale_shape_manual` - her vælger jeg `values=c(1,2,3)`, men der er en reference nedenunder, hvor I kan se, de mappings mellem de numeriske tal og de punkt former, så at I kan vælger jeres egne.


```{r,fig.width=5,fig.height=4}
ggplot(data=iris, aes(x = Sepal.Length, y = Sepal.Width, colour=Species)) +
  geom_point(aes(shape=Species)) + 
  scale_color_brewer(palette="Set2") +
  scale_shape_manual(values=c(1,2,3)) +
  theme_minimal()
```

***Reference for punkt former***


```{r,fig.width=4,fig.height=4,echo=FALSE,comment=FALSE}
df_shapes <- data.frame(shape = 0:25, shape_name = factor(paste0(0:25)))

ggplot(df_shapes, aes(0, 0, shape = shape)) +
  geom_point(aes(shape = shape), size = 5, fill = 'red', stroke = 2) +
  scale_shape_identity() +
  facet_wrap(~reorder(shape_name, shape)) +
  theme_void()
```

## Annotations 

### Tilføje labeller direkte på plottet.

Man kan bruge `geom_text()` til at tilføje tekst på punkterne direkte på plottet. Her skal man fortælle, hvad for nogle tekst skal være på plottet - her specificerer vi navne på biler fra datasættet `mtcars`. Plottet er en scatter plot mellem variabler `mpg` og `wt`.

```{r,fig.width=4,fig.height=4}
data(mtcars)

ggplot(mtcars,aes(x=mpg,y=wt)) + 
  geom_point() +
  geom_text(label=row.names(mtcars)) + 
  theme_minimal()
```

For at gøre det nemmere at læse kan man også fjerne de punkter:

```{r,fig.width=4,fig.height=4}
ggplot(mtcars,aes(x=mpg,y=wt)) + 
  #geom_point() +
  geom_text(label=row.names(mtcars)) + 
  theme_minimal()
```

Teksten på plottet er stadig meget svært at læse. En god løsning kan være at bruge R-pakken `ggrepel`.

### Pakken `ggrepel` for at tilføje tekst labeller

```{r}
#install.packages(ggrepel) #installere hvis nødvendeigt
```


For at anvende pakken `ggrepel` for det `mtcars` datasæt. Man erstatter bare `geom_text()` med `geom_text_repel()`. 

```{r,fig.width=4,fig.height=4}
library(ggrepel)
ggplot(mtcars,aes(x=mpg,y=wt)) + 
  geom_point() +
  geom_text_repel(label=row.names(mtcars)) + 
  theme_minimal()
```


Så kan vi se, at nu er der ingen navne som sidder lige overfor hinanden, fordi ggrepel har været dygtig til at placerer dem tæt på deres punkter med ikke ovenpå hinanden. Man kan også se her at der er nogle punkter, hvor funktionen har tilføjet en linje her for at gøre det klart, de punkt teksten referer til.

Man kan se, at vi fik en advarsel her. Så vi kan prøve hvad vi er blevet bedt om her, og fortæl, at vi vil have max.overlaps måske 20.

```{r}
library(ggrepel)
ggplot(mtcars,aes(x=mpg,y=wt)) + 
  geom_point() +
  geom_text_repel(label=row.names(mtcars),max.overlaps = 20) +
  theme_minimal()
```

Så vi kan se, at vi ikke længere få en advarsel, og vi har tekst for alle vores punkter her.


### Tilføje rektangler i regioner af interesse (`annotate`)

Ekstra: hvis man gerne vil fremhæv en bestemt region i plottet, kan man prøve `annotate`. Prøve at selv regne ud, hvad de muligheden indenfor `annotate` gå ud på.

```{r,fig.width=4,fig.height=4}
ggplot(mtcars,aes(x=mpg,y=wt)) + 
  geom_point() +
  geom_text_repel(label=row.names(mtcars)) +
  annotate("rect",xmin=18,xmax=23,ymin=2.5,ymax=3,alpha=0.2,fill="orange") +
  theme_minimal()
```

Man kan også tilføje nogle tekst på en bestemt lokation med `annotate`:

```{r,fig.width=4,fig.height=4}
ggplot(mtcars,aes(x=mpg,y=wt)) + 
  geom_point() +
  geom_text_repel(label=row.names(mtcars)) +
  annotate("rect",xmin=18,xmax=23,ymin=2.5,ymax=3,alpha=0.2,fill="orange") +
  annotate("text",x=25,y=2.75,label="Cars of interest",col="orange") + 
  theme_minimal()
```


## Opdele plots (`facet_grid`/`facet_wrap`) 

En stor fordele af at bruge `ggplot` er evne til at lave en `facet_grid` til at adskille grupperne i en variable over separate plotter. For eksempel:


```{r,fig.width=5,fig.height=4}
ggplot(iris,aes(x=Sepal.Length,fill=Species)) + 
  geom_density(alpha=0.5) + 
  theme_minimal()
```

bliver (ligger mærke til `~` her, som betyder at vi gerne vil opdele efter `Species`):

```{r,fig.width=5,fig.height=4}
ggplot(iris,aes(x=Sepal.Length,fill=Species)) + 
  geom_density(alpha=0.5) + 
  facet_grid(~Species) + 
  theme_minimal()
```

Vi leger lidt videre med `facet_grid()` i problemstillinger nedenfor.



<!-- ## Advanceret - funktionen theme -->

<!-- Se her: https://tidyverse.github.io/ggplot2-docs/reference/theme.html -->

<!-- ```{r} -->
<!-- ggplot(iris,aes(x=Sepal.Length,fill=Species)) +  -->
<!--   geom_density(alpha=0.5) +  -->
<!--   facet_grid(~Species) +  -->
<!--   theme_minimal() +  -->
<!--   theme(legend.position = "top") -->
<!-- ``` -->

## Problemstillinger

__1__) Lave quiz - "Quiz - ggplot2 part 2"

Vi arbejder med `Palmer Penguins`.

Data beskrivelse: *The palmerpenguins data contains size measurements for three penguin species observed on three islands in the Palmer Archipelago, Antarctica.*

```{r, echo=FALSE,comment=FALSE,warning=FALSE,out.width="20%"}
# Bigger fig.width
library(png)
include_graphics("plots/palmerpenguins.png")
```

```{r,comment=FALSE,warning=FALSE,message=FALSE}
#install.packages("palmerpenguins") #køre hvis ikke allerede installeret
library(palmerpenguins)
library(ggplot2)
library(tidyverse)
head(penguins)
```

Man kan bruge `?penguins` for at se flere detaljer om variable navner.

*I skal starte med at rydde op lidt med datasættet. Køre følgende for at fjerne række som har NA værdier:*

```{r}
penguins <- drop_na(penguins)
```

__2__) *Histogram*

Lave en histogram:

* `flipper_length_mm` på x-aksen
* brug `fill` til at opdele efter `species`
* specificer sort linjer omkring de bars, så man mere tydeligt kan se dem
* specificer hensigtsmæssige tekst (akserne, titel) og et tema

I få en advarsel: *`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.*

* Prøve at ændre indstillingen `bins` til noget andet indenfor `geom_histogram()`.

Det skal ser sådan ud:

```{r,echo=FALSE}
ggplot(data=penguins,aes(x=flipper_length_mm,fill=species)) +
  geom_histogram(bins = 50, alpha=0.5, colour="black") +
  ggtitle("Histogram of flipper length according to species") +
  xlab("Flipper length (mm)") +
  theme_minimal()
```

__3__) *Density plots og introduktion til facet_grid()*

__a)__ Lave et density plot af `body_mass_g`.

* Bruge `fill` til at opdele efter `sex`
* Gøre dine density plots gennemsigtige
* Skrive en sætning om forskellen i `body_mass_g` mellem females og males.
* Hvorfor tror du, at de densities har flere topper?

```{r,echo=FALSE,fig.width=4,fig.height=3}
ggplot(data=penguins,aes(x=body_mass_g,fill=sex)) +
  geom_density(alpha=0.5) +
  xlab("Body mass (g)") + ylab("Density") + 
  ggtitle("Density plots according to sex") +
  theme_minimal()
```

__b)__ Vi vil gerne adskille vores densities yderligere, efter `species`.

* Nu tilføj linjen `facet_grid(~species)` til dit plot og opdag, hvad der sker. 
* Skriv endnu en sætning, som beskriver forskellen i `body_mass_g` mellem de to køn over de tre `species`.

```{r,echo=FALSE,eval=FALSE}
ggplot(data=penguins,aes(x=body_mass_g,fill=sex)) +
  geom_density(alpha=0.5) +
  facet_grid(~species) +
  theme_minimal()
```



__4__) *Manuelt farver og punkter* __a__) Lave en scatter plot med `ggplot`: 

* `bill_length_mm` på x-aksen
* `bill_depth_mm` på y-aksen 
*  give hver `species` sin egen farve (automatisk)
*  sætte et tema

```{r,echo=FALSE,fig.width=4,fig.height=3.5,fig.cap="Min løsning",eval=FALSE}
ggplot(data=penguins,aes(x=bill_length_mm,y=bill_depth_mm,color=species)) +
  xlab("Bill length (mm") + ylab("Bill depth (mm)") +
  ggtitle("Scatter plot for penguin data") +
  theme_minimal()
```

__b__) Lav følgende ændringer til det plot:

* Ændre farver manuelt - prøve både at angive farver med `scale_color_manual` og afprøve også løsningen med pakken `RColorBrewer` (husk at installere/indlæse pakken hvis nødvendigt).
* Angiv at der skal være forskellige punkt former for hver `species`.
* Prøv at vælge nogle punkt former fra listen og specificer dem manuelt.

```{r,echo=FALSE,fig.width=4,fig.height=3.5,fig.cap="Min løsning"}
ggplot(data=penguins,aes(x=bill_length_mm,y=bill_depth_mm,color=species)) +
  geom_point(aes(shape=species)) +
  scale_color_brewer(palette = "Accent") + 
  xlab("Bill length (mm") + ylab("Bill depth (mm)") +
  ggtitle("Scatter plot for penguin data") +
  theme_minimal()
```

__5__) *Coordinate systemer* 

Tag overstående scatter plot fra __4__) og 

* bruge `coord_cartesian()` så at man fanger kun en bill længde mellem 40 og 50, og en bill depth mellem 16 og 19.  
* som ekstra afprøve pakken `ggrepel` (husk at installere/inlæse) ved at tilføje de navne af de forskellige øer som labels direkte på plottet (valfrig opfordring: man kan lave en subset af de data og specificere det indenfor den relevant `ggrepl` funktion, for at undgå, at de labels bliver plottet for punkterne udenfor området angivet med `coord_cartesian()`). 

```{r,echo=FALSE,fig.width=5,fig.height=4,fig.cap="Min løsning"}
peng_subset <- subset(penguins,bill_depth_mm >16 & bill_depth_mm<19 & bill_length_mm>40 & bill_length_mm<50)

ggplot(data=penguins,aes(x=bill_length_mm,y=bill_depth_mm,color=species)) +
  geom_point(aes(shape=species)) +
  coord_cartesian(ylim = c(16,19) , xlim = c(40,50)) +
  scale_color_brewer(palette = "Accent") + 
  #geom_text_repel(data=peng_subset,aes(label=island)) +
  xlab("Bill length (mm") + ylab("Bill depth (mm)") +
  ggtitle("Scatter plot for penguin data") +
  theme_minimal()
```


__6__) *Coordinate systemer* 

Lave en bar plot af counts for `species` opdelte efter `sex`. 

* Anvende en 'coordinate flip' for at få den til at være horizontal.
* Vælge nogle manuelt farver.
* Vælge et tema som I godt kan lide.

```{r,echo=FALSE,fig.width=4,fig.height=3,fig.cap="Min løsning"}
#Løsning
ggplot(data=penguins,aes(x=species,fill=sex)) +
  geom_bar(stat="count",position="dodge") + 
  coord_flip() + 
  scale_fill_brewer(palette = "Accent") +
  theme_minimal()
```

* I vil have at de tre arter få rækkefølgen, således at den `species` med de meste observationer er på toppen og den `species` med den færrest er på bunden. Ændre rækkefølgen af de tre `species`.
* Prøve også `scale_y_reverse()` og kig på resultatet.


```{r,echo=FALSE,fig.width=4,fig.height=4,eval=FALSE,fig.cap="Min løsning"}
#Løsning
ggplot(data=penguins,aes(x=species,fill=sex)) +
  geom_bar(stat="count",position="dodge") + 
  coord_flip() + 
  scale_fill_brewer(palette = "Accent") +
  scale_x_discrete(limits = rev(c("Adelie", "Gentoo","Chinstrap"))) + 
  theme_minimal()
```


__7__) Lave boxplots af `body_mass_g` opdelte efter `species`.

* Tilføj punkter ovenpå.
* Specificere nogle farver manuelt for de boxes.
* Giv det en hensigtsmæssig titel og nogle akser-labels
* Adskille plotterne ved at opdele efter de forskellige `islands`.

```{r,echo=FALSE,eval=FALSE,fig.width=5,fig.height=4,fig.cap="Min løsning"}
#Løsning
ggplot(data = penguins, aes(x=species,y=body_mass_g,fill=species)) +
  geom_boxplot(show.legend = FALSE) +
  geom_jitter(alpha=0.75,show.legend = FALSE,colour="grey") +
  scale_color_manual(values=brewer.pal(3,"Set2")) + 
  scale_fill_manual(values=brewer.pal(3,"Set2")) + 
  facet_grid(~island) +
  theme_classic()
```

* Ekstra: skrive en sætning om `body_mass_g` ser forskellige ud for `Adelie` over de tre `islands`.
* Ekstra: udforsk `?geom_violin` som erstatning for `geom_boxplot`.

__8__) *Annotations*. __a__) Lav et scatter plot af `bill_length_mm` vs `bill_depth_mm`.

* Anvend hensigtsmæssigt titel/labels/tema
* Anvend forskellige farver for de tre `species`.
* Tjekke funktionen `?annotate` og bruge den med `geom="text"` og hensigtsmæssigt x- og y-akse værdier til at tilføje `species` navne som tekst direkte på plottet (se eksempel nedenfor for at se, hvad jeg mener).
* Udforske hvordan man gøre teksten større, som jeg har gjorte i men løsning.
* Fjerne den legend med `show.legend = FALSE` indenfor `geom_point()`
* Ekstra: bruge `annotate` igen til at lave et orange rektangel omkring alle de blå punkter (se kursusnotaterne).


```{r,echo=FALSE,fig.width=4,fig.height=4}
ggplot(penguins,aes(x=bill_length_mm,y=bill_depth_mm,colour=species)) +
  geom_point(show.legend = FALSE) +
  annotate("text",40,20,label="Adelie",size=8) +
  annotate("text",55,19,label="Chinstrap",size=8) +
  annotate("text",45,15,label="Gentoo",size=8) +
  xlab("Bill length (mm)") + ylab("Bill depth (mm)") + 
  theme_minimal()
```



__b__) Vi vil gerne tilføje noget lodrette og vandrette linjer til plottet som specificer de middelværdier af de tre fordelinger.

* Bruge `tapply` til at beregne de gennemsnitlige værdier for henholdsvis `bill_length_mm` og `bill_depth_mm` opdelte efter `species`.
* Lave en dataramme, med kolonner `species`, `mlength` og `mdepth`, hvor `mlength` og `mdepth` er dine middelværdier for henholdsvis `bill_length_mm` og `bill_depth_mm`. Kalde det for `mydf`. Fk.

```{r,echo=FALSE}
mean_length <- tapply(penguins$bill_length_mm,penguins$species,mean)
mean_depth <- tapply(penguins$bill_depth_mm,penguins$species,mean)
mydf <- data.frame("species"=names(mean_length),"mlength"=mean_length,"mdepth"=mean_depth)
mydf[1,]
```

* For de lodrette linjer anvende `geom_vline()` og specificere din ny dataramme indenfor med `data=mydf`. Tilføj også `xintercept=mlength` og `colour=species` (husk at da `mlength` og `species` er variabler fra `mydf` skal man bruge `aes()`)   
* Tilføje de relevante vandrette linjer. 
* Specificer "dashed" linjer

Plotten skal ser sådan ud

```{r,fig.width=5,fig.height=5,echo=FALSE}
ggplot(penguins,aes(x=bill_length_mm,y=bill_depth_mm,colour=species)) +
  geom_point(show.legend = FALSE) + 
  geom_vline(data=mydf,show.legend = FALSE,aes(xintercept=mlength,colour=species),lty=2) +
  geom_hline(data=mydf,show.legend = FALSE,aes(yintercept=mdepth,colour=species),lty=2) +
  annotate("text",40,20,label="Adelie",size=8) +
  annotate("text",55,19,label="Chinstrap",size=8) +
  annotate("text",45,15,label="Gentoo",size=8) +
  xlab("Bill length (mm)") + ylab("Bill depth (mm)") + 
  theme_minimal()
```

__9__) Valgfri: Lav et scatter plot og inddrag `?scale_colour_gradient2` (se fk. https://michaeltoth.me/a-detailed-guide-to-ggplot-colors.html)


## Workshop opgave (OBS Fredag)

1) I uge arbejder vi direkte på en skabalon som jeg har lavet i rmarkdown. Filen hedder `markdown_visualisering.Rmd` og er tilgængelige på Absalon.

2) Jeg kommer rundt i breakout rooms og tilbudde min støtte.

3) Derefter poster jeg mine løsninger på problemer, som du måske kan bruge til at tage noget ekstra videre til næste gang.

4) På mandag gå vi igennem nogle af de punkter som I havde meste svært ved. 


## Ekstra notat: gemme dit plot

Her bruger vi R Markdown til at lave et rapport som indeholder vores plots, men det kan være at man gerne vil gemme sit plot som en fil på computeren. Til at gemme et plot kan man bruge kommandoen `ggsave()`:

```{r, eval=FALSE}
ggsave(myplot, "myplot.pdf")
```

Figuren vil blive gemt i den _working directory_. Filtypen `.pdf` kan erstattes med andre formater, for eksempel `.png` eller `jpeg` osv. Hvis man gerne vil tage sit plot og redigerer det videre (fk. Adobe Illustrater eller Inkscape), vil jeg anbefalder at I bruge `.pdf`.

Det kan være når man har gemt sit plot, vil man gerne ændre højden og bredden på plottet. Det kan man ændre med  `width` og `height`:

```{r, eval=FALSE}
ggsave(myplot, "myplot.pdf", width = 4, height = 4)
```


## Ekstra links

ggthemes pakke:

https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/

https://www.rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf

R Graphics cookbook

https://r-graphics.org/

Bar charts

https://www.r-graph-gallery.com/218-basic-barplots-with-ggplot2.html

## Slut for ugen

Nærværende kapitel har givet en introduktion til nogle af de grundlæggende elementer i, hvordan man visualiserer datarammer med `ggplot2`-pakken i `R`.

Næste uge begynder vi med R-pakken tidyverse.













<!-- ## Temear -->

<!-- Lad os begyndte med blot at ændre temaet, så vi får et mere minimalistisk _look_.  -->

<!-- ```{r, fig.width=5} -->
<!-- ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width)) + -->
<!--   geom_point(size=3) +  -->
<!--   theme_minimal() -->
<!-- ``` -->


<!-- Figur \@ref(fig:ggthemes) viser hvordan de forskellige _themes_ ser ud. -->

<!-- ```{r ggthemes, fig.width=7, fig.height=5, fig.cap="seks forskellige temaer", echo=FALSE, message=FALSE, warning=FALSE} -->
<!-- library(gridExtra) -->

<!-- plot.basic <- ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width)) + -->
<!--   geom_point(size=2) + ggtitle("theme_gray()") -->

<!-- plot.bw <- plot.basic + theme_bw() + ggtitle("theme_bw()") -->
<!-- plot.minimal <- plot.basic + theme_minimal() + ggtitle("theme_minimal()") -->
<!-- plot.classic <- plot.basic + theme_classic() + ggtitle("theme_classic()") -->
<!-- plot.dark <- plot.basic + theme_dark() + ggtitle("theme_dark()") -->
<!-- plot.light <- plot.basic + theme_light() + ggtitle("theme_light()") -->
<!-- #plot.eco <- plot.basic + theme_light() + ggtitle("theme_economist()") + scale_colour_economist() -->
<!-- grid.arrange(plot.basic, plot.bw, plot.minimal, plot.classic,plot.dark,plot.light, ncol=3) -->
<!-- ``` -->

