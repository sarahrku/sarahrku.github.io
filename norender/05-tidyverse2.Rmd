# Bearbejdning dag 2


```{r, echo=FALSE,fig.width = 1,fig.height=1,comment=FALSE,warning=FALSE,out.width="15%"}
# Bigger fig.width
library(png)
library(knitr)
include_graphics("plots/hex-tidyverse.png")
```

```{r,echo=FALSE,warning=FALSE,message=FALSE}
library(tidyverse)
library(titanic)
titanic <- as_tibble(titanic_train)

titanic_clean <- titanic %>% 
    select(-Cabin) %>%
    drop_na() 
```


## Indledning og læringsmålene

I dag skal vi arbejde videre med `tidyverse`, især på pakken `dplyr` og `tidyr`, som kan bruges til at andre på strukturen af de data, således at det passer til den struktur, som kræves for at lave plots med `ggplot2`.

Det er ofte tilfældet indenfor biologi, at man har sine data i den ene dataramme og nogle ekstra sample oplysninger i den anden dataramme. Derfor vil vi gerne have en måde, at integrere de to datarammer i R, som gøre, at vi kan inddrage de ekstra oplysninger når vi lave plots af de data. 


### Læringsmålene

I skal være i stand til at

* Benytte kombinationen af `group_by()` og `summarise()`.
* Forbinde `tidyverse` kode og `ggplot2` kode sammen for at svare på spørgsmål om datasættet.
* Forstå forskellen mellem `wide` og `long` data og bruge `pivot_longer()` til at facilitere plotting
* Benytte `left_join()` til at tilføje sample information til datasættet.

### Videoer

* Video 1 - vi skal kig lidt nærmere på `group_by()` + `summarise()` og forbinde `tidyverse` kode og `ggplot2` kode sammen med %>%/+.

Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/546910681
```{r,echo=FALSE}
library("vembedr")

embed_url("https://vimeo.com/546910681")
```


* Video 2 - wide/long data forms og `pivot_longer()` og bruge den i ggplot2

Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/546910660
```{r,echo=FALSE}
library("vembedr")

embed_url("https://vimeo.com/546910660")
```


* Video 3 - eksempel med titanic summary statistics og facet_wrap()

Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/547096274
```{r,echo=FALSE}
library("vembedr")

embed_url("https://vimeo.com/547096274")
```


* Video 4: left_join of tables with extra sample information and plot

Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/549630870
```{r,echo=FALSE}
library("vembedr")

embed_url("https://vimeo.com/549630870")
```



<!-- * Arrangerer multiple plots with `grid.arrange`. -->

## dplyr: `group_by()` med `summarise()`

Man kan lave summary statistics med funktionen `summarise()`. Man plejer at kombinere `summarise()` med `group_by()`, som anvendes til at opdele datasættet efter en eller flere variabler. Her kan vi begynde at stille spørgsmål omkring vores data. For eksempel: havde mænd eller kvinde en højre sandsynlighed for at overleve tragedien?    

Lad os starte med løsningen med `tapply` til at udregne proportionen af mænd og kvinde der overlevede: her opdele vi kolonnen `Survived` efter kolonnen `Sex` og tager middelværdien, som resultater i proportionen der overlevede efter køn (da `Survived` er kodet sådan at 1 betyder at man overlevede og 0 betyder at man ikke overlevede). 

```{r,tidy=FALSE}
#tapply løsning
tapply(titanic_clean$Survived,titanic_clean$Sex,mean)
```

Lad os skifter over til den `tidyverse` løsning. Lad os tage udgangspunkt i `summarise()`: som et eksempel af hvordan man bruger funktionen, vil vi beregner en variable der hedder "medianFare" som er lig med median(fare).

```{r}
titanic_clean %>%
  summarise("medianFare"=median(Fare))
```

Vi får faktisk en ny dataramme her, med kun variablen som vi lige har specificeret. Vi er interesseret i proportionen, der overlevede, så vi behøver at tage middelværdien af variablen `Survived`. Lad os gøre det med `summarise()`:

```{r}
titanic_clean %>%  
  summarise(meanSurvived = mean(Survived))
```

Få at svare på spørgsmålet er vi også nødt til at opdele efter kolonnen `Sex`. Vi kan bruge den kombinering af `group_by()` og `summarise()` - vi opdele efter `Sex` ved at anvende funktionen `group_by()` og derefter bruger `summarise()` til at oprette en kolon der hedder `meanSurvived`, der viser proportionen der overlevede for female and male.

```{r}
#tidyverse løsning
titanic_clean %>%
    group_by(Sex) %>%
    summarise(meanSurvived = mean(Survived))
```

Lad os tage resultatet fra ovenpå og visualiserer det i et barplot, som i nedenstående:

```{r,fig.width=3,fig.height=4}
titanic_clean %>%  
  group_by(Sex) %>% 
  summarise(meanSurvived = mean(Survived)) %>%
  ggplot(aes(x=Sex,y=meanSurvived,fill=Sex)) + 
  geom_bar(stat="identity",show.legend = FALSE) + theme_minimal()
```


### Reference af `summarise()` funktioner

Nogle fuktioner man ofte bruge med `summarise()` (der er mange andre muligheder).

fuktion | beskrivelse
--- | ---
`mean()` | to give us the mean value of a variable.
`sd()` | to give us the standard deviation of a variable.
`min()` | giving us the lowest value of a variable.
`max()` | giving us the highest value of a variable.
`n()` | giving us the number of observations in a variable. and many more.
`first()` | first values

### Flere summary statistic på én gang

Vi kan også lave flere summary statistics på én gang. For eksempel, lad os anvende funktionen `group_by` med Sex igen, men beregner flere forskellige summary statistics:


```{r}
titanic_clean_summary_by_sex <- titanic_clean %>%  
  group_by(Sex) %>% 
  summarise(count = n(),                    #count
            meanSurvived = mean(Survived),  #middelværdi survived
            meanAge = mean(Age),            #middelværdi age
            propFirst = sum(Pclass==1)/n()) #proportionen i første klass
titanic_clean_summary_by_sex
```


Igen kan denne summary table bruges som et datasæt til at lave et plot med `ggplot2`. Bemærk at her bruger vi `stat="identity"`, fordi vi skal ikke tælle observationerne op, men bare plot præcis de tal som er i datarammen på y-aksen. I nedenstående laver vi barplots for `meanAge` og `propFirst` - de er plottet ved at bruge to forskellige `ggplot` kommandoer og bemærk, at det er plottet ved siden af hinanden med en funktion der hedder `grid.arrange()` fra R-pakken `gridExtra`.

 
```{r,fig.width=5,fig.height=3,comment=FALSE,message=FALSE,warning=FALSE}
plotA <- ggplot(data=titanic_clean_summary_by_sex,aes(x=Sex,y=meanAge,fill=Sex)) + 
  geom_bar(stat="identity",show.legend = FALSE) + 
  theme_minimal()

plotB <- ggplot(data=titanic_clean_summary_by_sex,aes(x=Sex,y=propFirst,fill=Sex)) + 
  geom_bar(stat="identity",show.legend = FALSE) + 
  theme_minimal()

library(gridExtra)
grid.arrange(plotA,plotB,ncol=2) #plot both together
```
 
Vi kan se, at females var i gennemsnit lidt yngere end males, og havde en højere sandsynlighed for at være i første klass. Et interessant spørgsmål er, hvordan man kan lave ovenstående plots uden at bruge to forskellige `ggplot` kommandoer - altså, en automatiske løsning hvor vi kan plotte flere summary statistiks med kun én `ggplot` kommando. Vi kommer til at se hvordan man gøre det med at første lave datasættet om til long form.

### Mere kompliceret `group_by()`

Lad os også beregne hvor mange passagerer der var efter både deres klass, og hvor de gik ombord skibet:

```{r,tidy=FALSE}
titanic_clean %>%
   group_by(Embarked, Pclass) %>% # group by multiple variables... 
   summarise(count = n())
```

Man kan se at de flest gik om bord i Southampton (S), men der var også forholdsvis mange første klass passagerer der gik om bord i Cherbourg (C). Lad os gå videre med vores `Survived` eksempel og beregne proportionen der overlevede efter de tre variabler `Adult`, `Sex` og `Pclass`.

```{r}
titanic_clean_summary_survived <- titanic_clean %>%  
  mutate(Adult = ifelse(Age>=18,"Adult","Child")) %>%
  group_by(Adult,Sex,Pclass) %>% 
  summarise(meanSurvived = mean(Survived))
titanic_clean_summary_survived
```

Og så kan vi også bruge resultatet ind i en `ggplot`, hvor vi kombinerer de tre variabler og adskiller efter `Pclass`:

```{r,fig.width=5,fig.height=4}
ggplot(titanic_clean_summary_survived,aes(x=Sex,y=meanSurvived,fill=Adult)) +
  geom_bar(stat="identity",position = "dodge") + 
  facet_grid(~Pclass) + 
  ylab("Proportion survived") +
  theme_bw()
```


## Tidyr pakke - Wide og Long data

__Tidy data__ findes i to former: wide data og long data. Det kan være nyttigt at transformere dataframen fra den ene form til den anden, for fk. at lave et bemstemt plot med `ggplot2`-pakken. Indenfor pakken `tidyr` er der funktioner som kan bruges til at lave disse transformeringer.

Inden vi begynde at kigge lidt nærmere på `tidyr` skal vi beskrive, hvad betyder long data og wide data.

```{r, echo=FALSE,fig.width = 1,fig.height=1,comment=FALSE,warning=FALSE,out.width="75%",fig.cap="source: https://www.garrickadenbuie.com/project/tidyexplain/"}
# Bigger fig.width
library(png)
library(knitr)
include_graphics("plots/original-dfs-tidy.png")
```


__Wide data__: Her har man en kolon til hver variabel og en række til hver observation. Det gøre de data nem at forstå og denne data type findes ofte indenfor biologi - for eksempel hvis man har forskellige samples (treatments, controls, conditions osv.) som variabler. 

__Long data__: Med long data har man værdier samlet i en enkel kolon og en kolon som en slags nøgle, som fortæller også hvilken variable hver værdi hørte til i den wide format. Datasættet er stadig betragtet som __tidy__ men informationen opbevares på en anden måde. Det er lidt sværer at læse men nemmere at arbejde med når man analyser de data.

Når man transformer data fra wide til long eller omvendt, kaldes det for __reshaping__.

### Tidyr pakke - oversigt

Her er en oversigt over de fire vigtigste funktioner fra R-pakken `tidyr`.

`tidr` funktion | Beskrivelse
--- | ---
`pivot_longer()` | short til long
`pivot_wider()` | long til short
`separate()` |  opdele strings fra en kolon til to
`unite()` | tilføje strings sammen ind fra to til én kolon

### Wide -> Long med `pivot_longer()`

Lad os arbejde med datasættet `Iris`. Man få Iris` i long form med følgende kommando:

<!-- Iris based solution https://jcoliver.github.io/learn-r/012-intro-tidyverse.html -->

```{r,eval=FALSE}
iris %>% pivot_longer(cols = -Species)
iris %>% pivot_longer(cols = where(is.numeric))
```


```{r, echo=FALSE,fig.width = 1,fig.height=1,comment=FALSE,warning=FALSE,out.width="100%",fig.cap="wide til long med Iris"}
# Bigger fig.width
library(png)
library(knitr)
include_graphics("plots/wide_to_long.png")
```


Til venstre har vi målingerne i datasættet over fire forskellige kolonner som hedder `Sepal.Length`, `Sepal.Width`, `Petal.Length` og `Petal.Width`, og en ekstra kolon der skelne imellem de tre `Species`. Til højre har vi fået alle målingerne ind i en enkel kolon der hedder `values`, og så bruger man en anden 'nøgle' kolon der hedder `name` til at fortælle os om det er en måling for `Sepal.Length` eller `Sepal.Width` osv.

Man specificer `cols=-Species`, fordi det kun er kolonnerne med målinger som vi gerne vil have samlet i en enkel kolon, og det inkluderer så ikke Species.

Ovenstående er den samme som at fortælle, hvilke variabler skal med - vi vil have alle numeriske variabler i en enkel kolon.

```{r}
iris %>% pivot_longer(cols = where(is.numeric))
```

Jeg kan kalde de kolonner navne for målingerne og nøglen til nogle andre en default: for eksempel i nedenstående skal målingerne hedde `measurements` og nøglen hedde `trait`.

```{r}
iris.long <- iris %>% pivot_longer(cols = -Species,
                                    names_to = "trait",
                                    values_to = "measurement")
```


```{r, echo=FALSE,fig.width = 1,fig.height=1,comment=FALSE,warning=FALSE,out.width="100%"}
# Bigger fig.width
library(png)
library(knitr)
include_graphics("plots/wide_to_long_names.png")
```


Man kan for eksempel bruge den long form den til at visualisere samtlige mulige boxplots opdelt efter Species og trait på samme plot:


```{r,fig.width=6,fig.height=4}
ggplot(iris.long,aes(y=measurement,x=Species,fill=Species)) + 
  geom_boxplot() + 
  facet_grid(~trait) +
  theme_bw()
```


### `separate()`

Funktionen `separate()` fra pakken `tidyr` kan bruges til at opdele to forskellige dele som eksisterer i samme kolon. For eksempel, i `iris` har vi variabler med navne `Sepal.Width`, `Sepal.Length` osv. - man kan forestille sig, at opdele disse navne over to kolonner i stedet for en - fk. "Sepal" og "Width" i tilfældet af `Sepal.Width`. I nedenstående kan man se, hvordan man anvende `separate()`.

```{r}
iris %>%
  pivot_longer(cols = -Species, names_to = "trait", values_to = "measurement") %>%
  separate(col = trait, into = c("part", "measure"),sep = "\\.") %>% 
  head()
```

Man specificerer variablen `trait`, og at det skal opdeles til to variabler `part` og `measure`. Vi angiver `sep = "\\."` som betyder, at vi gerne vil have `part` som delen af `trait` foran '.' og `measure` som delen af `trait` efter `.`. Vi bruger "\\." til at fortælle, at vi er interesseret i punktum og ikke en "anonym character", som punktum plejer at betyde i "string"-sprog. Man behøver faktisk ikke at specifice `sep = "\\."` i dette tilfælde - som standard kigger funktionen efter 'non-character' tegne og bruger dem til at lave opdelingen.

Samme resultat:

```{r}
iris %>%
  pivot_longer(cols = -Species, names_to = "trait", values_to = "measurement") %>%
  separate(col = trait, into = c("part", "measure")) %>% 
  head()
```


Bruger resultatet i et plot:

```{r}
iris %>%
  pivot_longer(cols = -Species, names_to = "trait", values_to = "measurement") %>%
  separate(col = trait, into = c("part", "measure")) %>%
  ggplot(aes(y=measurement,x=part,fill=part)) + 
  geom_boxplot() + 
  facet_grid(~measure) +
  theme_bw()
```

Se også `unite()` som gøre de modsatte til `separate()`.

## Eksempel: Titanic summary statistics

Lad også tage vores Titanic summary statistic eksempel hvor man andvender de forskellige koncepter fra ovenstående.

* `group_by()` og `summarise()`

Vi laver vores summary statistics som i ovenstående.

```{r}
titanic_clean_summary_by_sex <- titanic_clean %>%  
  group_by(Sex) %>% 
  summarise(count = n(),
            meanSurvived = mean(Survived),
            meanAge = mean(Age),
            propFirst = sum(Pclass==1)/n())
```

* `pivot_longer()`

Vi transformerer eller __reshape__ datarammen fra wide data til long data. Vi vil få kun de summary statistics samlet i en enkel kolon, så variablen `Sex` ikke skal med.

```{r}
titanic_clean_summary_by_sex %>% pivot_longer(cols=-Sex)
```

* `ggplot()` med `facet_grid()`

Vi kombinerer `pivot_longer()` med et plot af vores summary statistics og benytte `facet_grid()` til at separere ved de forskellige statistiker.

```{r}
titanic_clean_summary_by_sex %>% 
  pivot_longer(cols=-Sex) %>%
  ggplot(aes(x=Sex,y=value,fill=Sex)) + 
  geom_bar(stat="identity") + 
  facet_grid(~name) +
  theme_bw()
```

* `facet_wrap()`

Vi laver den sammen som ovenstående men specificerer `facet_wrap()` i stedet for `facet_grid()` - indenfor `facet_wrap()` kan man bruge indstillingen `scales="free"` som gøre, at de fire plots få hver deres egne akse limits.

```{r}
titanic_clean_summary_by_sex %>% 
  pivot_longer(cols=-Sex) %>%
  ggplot(aes(x=Sex,y=value,fill=Sex)) + 
  geom_bar(stat="identity") + 
  facet_wrap(~name,scales="free",ncol=4) +  
  theme_bw()
```


### Demonstration af `pivot_wider()`

<!-- Vi bruger den næsten ikke så meget som `pivot_longer()` men bare for at demonstrere. -->



* Wide -> Long
```{r}
titanic_clean_summary_by_sex %>% 
  pivot_longer(cols=-Sex)
```

* Wide -> Long --> Wide

```{r}
titanic_clean_summary_by_sex %>% 
  pivot_longer(cols=-Sex)  %>%
  pivot_wider()
```



## Tilføje sample oplysninger med `left_join()`

For at bedste demonstrere scenariet, har jeg lavet nogle fiktiv data fra et eksperiment, hvor man indhenter målinger over 100 tidspunkter, for to konditioner (treatment og control). Der er tre replikater til hver kondition. Jeg har også lavet en table, som viser forskellige oplysninger om de samples, som ikke er med i de egentlige data.

<!-- ```{r,echo=TRUE} -->
<!-- data_exper <- read.table("https://www.dropbox.com/s/hb7m63agz4jti6w/fictive_left_join.txt?dl=1",header=T) -->
<!-- head(data_exper) -->

<!-- samples <- c("cl0_rep1", "cl0_rep2", "cl0_rep3","tm5_rep1", "tm5_rep2", "tm5_rep3") -->
<!-- condition <- gsub("(.+)_rep[1|2|3]","\\1",samples) -->
<!-- replicate <- gsub(".+_rep([1|2|3])","\\1",samples) -->
<!-- batch <- c("A","B","A","B","A","B") -->
<!-- condition <- c(rep("WT",3),rep("mutant",3)) -->
<!-- background <- c(rep("cl0",3),rep("tm5",3)) -->
<!-- sample_info <- data.frame("sample"=samples,"condition"=condition,"replicate"=replicate,"batch"=batch) -->
<!-- ```  -->

<!-- # ```{r} -->
<!-- # data("ToothGrowth") -->
<!-- # ToothGrowth %>%  -->
<!-- #   group_by(supp,dose) %>%  -->
<!-- #   summarise("mean_len" = mean(len)) %>%  -->
<!-- #   ungroup %>%  -->
<!-- #   pivot_wider(names_from = c("supp"),values_from="mean_len") %>% -->
<!-- #   mutate(dose = recode(dose,`0.5` = "low", -->
<!-- #                             `1.0` = "medium", -->
<!-- #                             `2.0` = "high")) %>% pivot_longer(-dose) -->
<!-- # ``` -->


```{r}
gene_table <- as_tibble(read.table("https://www.dropbox.com/s/6ll8ezrskly8joi/mouse_2gene_expr.txt?dl=1",header=T))
coldata <- as_tibble(read.table("https://www.dropbox.com/s/el3sm9ncvzbq6xf/bottomly_phenodata.txt?dl=1"))
```

Lad os kigge på datasættet `data_expr`:


```{r}
gene_table
```

Lad os også kigge på de sample oplysninger, som kan være nyttige at inddrage i vores analyse/plotter for at undersøge eventualle batch effekter osv.

```{r}
coldata
```

Som man kan se, har vi en kolon som viser hvilke kondition og replikate vores samples kommer fra (det er også oplagt fra sample navne her, men det er ikke altid), samt den batch, hver sample kommer fra. For at integrere de to tables, skal vi første have de data i __Long form__. 

```{r}
data_tp <- gene_table %>% 
  pivot_longer(-gene,names_to = "column") 
```




<!-- ```{r} -->
<!-- head(data_exper) -->
<!-- ``` -->

<!-- Lad os også kigge på de sample oplysninger, som kan være nyttige at inddrage i vores analyse/plotter for at undersøge eventualle batch effekter osv. -->

<!-- ```{r} -->
<!-- head(sample_info) -->
<!-- ``` -->

<!-- Som man kan se, har vi en kolon som viser hvilke kondition og replikate vores samples kommer fra (det er også oplagt fra sample navne her, men det er ikke altid), samt den batch, hver sample kommer fra. For at integrere de to tables, skal vi første have de data i __Long form__.  -->

<!-- ```{r} -->
<!-- data_long <- data_exper %>% pivot_longer(cols= -x,  -->
<!--                                         names_to="sample", -->
<!--                                         values_to="measurement") -->
<!-- head(data_long) -->
<!-- ``` -->



### Fuktionen `left_join()` fra dplyr-pakken

Funktionen `left_join()` er en del af pakken `dplyr` som vi har arbejdet meget med indtil videre i kurset. Her er en meget kort beskrivelse af de fire hoved `join` funktioner.

funktion | Beskrivelse
--- | ---
`left_join()` | Join matching rows from second table to the first
`right_join()` | Join matching rows from the first table to the second
`inner_join()` | Join two tables, returning all rows present in both
`full_join()` | Join data with all possible rows present

Vi fokuserer her på funktionen `left_join()` fordi den er den meste brugbart i biologiske data analyser. Her er en grafiske demonstration af `left_join()`:


```{r, echo=FALSE,fig.cap="left_join graphical demonstration (source https://mgimond.github.io/ES218/Week03c.html)",comment=FALSE,warning=FALSE,out.width="60%"}
# Bigger fig.width
library(png)
library(knitr)
include_graphics("plots/left_join.png")
```


### Anvende `left_join()` for vores fiktiv dataset.

For at bedste forstå funktionen `left_join()` skal vi afprøve den med vores datasæt. Her tager vi udgangspunkt i `data_long` og så tilføjer de data fra `sample_info`. Her angiver vi `by = "sample"` fordi det er navnet til kolonnen som vi geerne vil bruge til at forbinde de to datarammer - altså, det er med i begge to datarammer, så `left_join()` kan bruge den som en slags nøgle til at vide, hvor alle de forskellige oplysninger skal tilføjes.

```{r}
data_long_join <- data_tp  %>% left_join(coldata,by="column")
```

Nu at vi har fået forbundet de to datarammer, kan man inddrage de ekstra oplysninger vi har fået i et plot. Her laver vi et plot med en farve til hver kondition og et plot med en farve til hver batch.


```{r,fig.width=6,fig.height=4}

gg2 <- data_long_join %>% 
  ggplot(aes(y=value,x=as.factor(strain),fill=gene)) + 
  geom_boxplot() + 
  facet_wrap(~gene,scales="free") +
  theme_minimal() +
  theme(legend.position = "none") + 
  ggtitle("Expression split according to strain")


gg1 <- data_long_join %>% 
  ggplot(aes(y=value,x=as.factor(batch),fill=gene)) + 
  geom_boxplot() + 
  facet_wrap(~gene,scales="free") +
  theme_minimal() +
  theme(legend.position = "none") +
  ggtitle("Expression split according to batch")


library(gridExtra)
grid.arrange(gg1,gg2,ncol=2)
```


<!-- ```{r,fig.width=8,fig.height=3.5} -->
<!-- gg1 <- ggplot(data_long_join,aes(y=measurement,x=x,colour=condition)) +  -->
<!--   geom_point(size=0.75) + -->
<!--   theme_minimal() + -->
<!--   scale_color_brewer(palette = "Set2") + -->
<!--   theme(panel.grid = element_blank()) -->

<!-- gg2 <- ggplot(data_long_join,aes(y=measurement,x=x,colour=batch)) +  -->
<!--   geom_point(size=0.75) + -->
<!--   theme_minimal() + -->
<!--   scale_color_brewer(palette = "Set3") + -->
<!--   theme(panel.grid = element_blank()) -->

<!-- library(gridExtra) -->
<!-- grid.arrange(gg1,gg2,ncol=2) -->
<!-- ``` -->


Vi kan se, at man kan godt kan skelne imellem de målingerne for de to konditioner, men ikke så meget for de to batches. Det betyder, at vores kondition effekt er stærkere end den batch effekt, som er en god tegn for vores analyse af datasættet.

<!-- ```{r} -->
<!-- #plant <- matrix(PlantGrowth$weight,nrow=10,ncol=3) -->
<!-- ``` -->





## Problemstillinger

__1__) Lav quizzen - "Quiz - tidyverse - part 2".

*Vi øver os med titanic. Inlæs de data og lave oprydningen med følgende kode:*

```{r,echo=TRUE,eval=FALSE,comment=FALSE,message=FALSE,warning=FALSE}
library(tidyverse)
library(titanic)
titanic <- as_tibble(titanic_train)

titanic_clean <- titanic %>% 
    select(-Cabin) %>% 
    drop_na()
```

__2__) *`summarise()`*. Fra `titanic_clean` beregne den median alder af alle passagerer ombord skibet.

```{r,eval=FALSE,echo=TRUE}
titanic_clean %>%
    summarise(....) #rediger her
```

* I samme kommando beregne også den maksimum alder og minimum alder, samt med den standard afvigelse af alder. Datarammen skal ser sådan ud:

```{r,eval=TRUE,echo=FALSE}
titanic_clean %>%
  summarise(mean_alder=mean(Age),
            max_alder=max(Age),
            min_alder=min(Age),
            sd_alder=sd(Age))
```


__3__) *`group_by()` og `summarise()`*. Beregne samme summary statistics som i __2__) men anvende `group_by()` til at først opdele efter variablen `Pclass`.

```{r,echo=FALSE,eval=FALSE}
titanic_clean %>%
    group_by(Pclass) %>%
    summarise(mean_alder=mean(Age),
            max_alder=max(Age),
            min_alder=min(Age),
            sd_alder=sd(Age))
```

* Lave et barplot med `stat="identity"` som viser den gennemsnitlige alder på y-aksen opdelt efter `Pclass` på x-aksen. 
* OBS: prøve at tilføje `fill=Pclass` til dit plot og kigge på farverne/legend. Hvad er skete? Kigg på datarammen `titanic_clean` (som skulle være en `tibble` her) og tjekke datatypen. 
* Gør variablen til en "factor" variable indenfor plottet. 

```{r,echo=FALSE,eval=FALSE}
titanic_clean %>%
    group_by(Pclass) %>%
    summarise(mean_alder=mean(Age),
            max_alder=max(Age),
            min_alder=min(Age),
            sd_alder=sd(Age)) %>%
  ggplot(aes(x=factor(Pclass),y=mean_alder,fill=factor(Pclass))) + geom_bar(stat="identity") 
```


__4__) *`group_by()` og `summarise()`*. Beregne samme summary statistics som i __2__) men anvende `group_by()` til at først opdele efter både variablerne `Pclass` og `Sex`. Man få en advarsel "`summarise()` has grouped output by 'Pclass' ... " som du kan se bort fra. 

```{r,echo=FALSE,eval=FALSE}
titanic_clean %>%
    group_by(Pclass,Sex) %>%
    summarise(mean_alder=mean(Age),
            max_alder=max(Age),
            min_alder=min(Age),
            sd_alder=sd(Age))
```

* Lave et barplot med `stat=="identity"` som viser den gennemsnitlige alder opdelt efter `Pclass`, adskilte efter `Sex` (`facet_grid()`)


```{r,echo=FALSE,eval=FALSE}
titanic_clean %>%
    group_by(Pclass,Sex) %>%
    summarise(mean_alder=mean(Age),
            max_alder=max(Age),
            min_alder=min(Age),
            sd_alder=sd(Age)) %>%
  ggplot(aes(x=factor(Pclass),y=mean_alder,fill=factor(Pclass))) + 
  geom_bar(stat="identity") + 
  facet_grid(~Sex) + 
  theme_bw()
```

__5__) *Ekstra øvelse med `group_by()` og `summarise()`*. Med `titanic_clean` som udgangspunkt angiv både Pclass og Embarked i `group_by()` og brug `summarise()` til at beregne de gennemsnitlige `Fare` til passagerene. 

```{r,echo=FALSE,eval=FALSE}
titanic_clean %>%
  filter(Embarked!="") %>%
  group_by(Embarked,Pclass) %>%
  summarise("meanFare"=mean(Fare)) %>% 
  ggplot(aes(x=Embarked,y=meanFare,fill=Embarked)) + 
  facet_grid(~Pclass) + 
  geom_bar(stat="identity") + 
  theme_bw()
```

* OBS: Der er et par observationer med en blank værdi for "Embarked" - bruge `filter()` i linjen før man anvender `group_by()` for at først få dem fjernet (Hint: benyt `!=` tegn).
* Lav et barplot med `Embarked` på x-aksen og den gennemsnitlige `Fare` på y-aksen og adskille efter `Pclass`.
* Hvilke gruppe betalte mest i gennemsnit for deres billet?

__6__) *`group_by()` med tre variabler og `summarise()`*. Afprøve en kombination med tre forskellige variabler indenfor `group_by()` og bruge `summarise()` til at beregne middelværdien for `Age`. 

* Leg med at lave et plot for at visualisere de data. Idé: som mulighed kan man tilføje variabler til `facet_grid()` - for eksempel `facet_grid(~Pclass + Sex)`.

```{r,eval=FALSE,echo=FALSE}
titanic_clean %>%
  filter(Embarked!="") %>%
  group_by(Embarked,Pclass,Sex) %>%
  summarise("meanFare"=mean(Fare)) %>% 
  ggplot(aes(x=Embarked,y=meanFare,fill=Sex)) + 
  facet_grid(~Pclass + Sex) + 
  geom_bar(stat="identity",position="dodge") + 
  theme_bw()
```



__7__) *`pivot_longer()`*

* Lave en ny dataramme fra `titanic_clean` der viser tre summary statistics opdelt efter Survived: den gennemsnitlige alder, den gennemsnitlige `Fare` og proportionen som er "male".

```{r,echo=FALSE,eval=FALSE}
titanic_stats <- titanic_clean %>%
  group_by(Survived) %>%
  summarise(meanAge=mean(Age),
            propMal=sum(Sex=="male")/n(),
            meanFare=mean(Fare))
```


* Benyt `pivot_longer()` til at få de resulterende dataramme i Long form. Husk at angiv `-Survived` da vi kun vil have vores beregnet værdier med.
* Bruge resultatet til at lav et barplot med `Survived` på x-aksen og `value` på y-aksen (husk at angiv i plot, at `Survived` er en factor). 
* Anvend `facet_wrap()` til at adskille efter `name` og bruger indstillingen `scales="free"`.

```{r,echo=FALSE,eval=FALSE}
titanic_stats %>% pivot_longer(-Survived) %>%
  ggplot(aes(x=factor(Survived),y=value,fill=name)) + 
  geom_bar(stat="identity") + 
  theme_bw() + 
  facet_wrap(~name,ncol=3,scales = "free")
```


__8__) *Mere øvelse med `pivot_longer()`*

Her er nogle fiktiv data om hjerterytmene for seks forskellige patienter, efter at have taget fire forskellige lægemidler:

```{r}
heart_rate <- tibble("patient"=c("George","Sally","Henry","Peter","Charlotte","Jason"),"drugA"=c(72,84,64,60,74,88),"drugB"=c(74,84,66,58,72,87),"drugC"=c(80,88,68,64,78,88),"drugD"=c(68,76,64,58,70,72))
heart_rate
```

* Bruge `pivot_longer()` til at få datasættet i Long form. Er der nogle kolonner som ikke skal med i den enkel kolon med værdier? Kalde den kolon med værdier "heartrate" og den nøgle kolon med variable-navne "drug".
* Bruge `group_by()` og `summarise()` til at beregne den gennemsnitlige heartrate efter drug.
* Lave et plot som viser den gennemsnitlige heartrate efter drug.

```{r,echo=FALSE,eval=FALSE}
heart_rate %>% 
  pivot_longer(-patient,names_to="drug",values_to="heartrate") %>%
  group_by(drug) %>%
  summarise(mean_rate = mean(heartrate)) %>%
  ggplot(aes(x=drug,y=mean_rate,fill=drug)) + 
  geom_bar(stat="identity") + 
  theme_minimal()
```


__9__) *`Pivot_wider()`* Vi har en `tribble` som jeg har kopiret fra https://r4ds.had.co.nz/index.html.


```{r}
people <- tribble(
  ~name,             ~names,  ~values,
  #-----------------|--------|------
  "Phillip Woods",   "age",       45,
  "Phillip Woods",   "height",   186,
  "Jessica Cordero", "age",       37,
  "Jessica Cordero", "height",   156,
  "Brady Smith",     "age",       23,
  "Brady Smith",     "height",   177
)
```

Brug `pivot_wider()` på `people`. Vi er nødt til at specificer `names_from` og `values_from` indenfor `pivot_wider()` - prøv at angiv de relevante kolonner.

```{r,echo=FALSE,eval=FALSE}
pivot_wider(people,names_from = "names",values_from = "values")
```


__10__) *`Separate()` øvelse* 

* Benytt funktionen `Separate()` til at opdele variablen `Name` ind til to variabler, "Surname" og "Rest" (Hint: bruge `sep=", "` for at undgå, at man få en mellemrum lige før "Rest").
* Anvend `Separate()` en gang til, men for at opdele variablen `Rest` into to variabler, "Title" og "Names". Hvad bruger man som `sep`? (Hint: husk at bruge "\\\\" foran en punktum).

* Optæll hvor mange der er i hver af de forskellige "Titles" og beregne også den maksimum og den minimum alder for hver "Title".

```{r,eval=FALSE,echo=FALSE}
titanic_clean %>% 
  separate(Name,into=c("Surname","Rest"),sep=", ") %>% 
  separate(Rest,into=c("Title","Names"),sep="\\. ") %>%
  group_by(Title) %>%
  summarise(nPersons = n(),
            maxAge = max(Age),
            minAge = min(Age))
```


__11__) Valgfri ekstra hvis man er færdig: lave en ny dataramme med alle passagerer, der hedder "Alice" eller "Elizabeth" (brug Google her).

```{r,eval=FALSE,echo=FALSE}
titanic_clean %>% 
  filter(str_detect(Name, 'Alice|Elizabeth'))
```



<!-- ```{r,fig.width=3,fig.height=3.75} -->
<!-- iris %>% -->
<!-- mutate(Sepal.Area = Sepal.Width * Sepal.Length) %>% -->
<!-- filter (Sepal.Area > 15) %>% -->
<!-- group_by(Species) %>% -->
<!-- summarise(Sepal.Area.Mean = mean(Sepal.Area)) %>% -->
<!-- ggplot(aes(y = Sepal.Area.Mean, x = Species, fill = Species)) + -->
<!-- geom_bar(stat="identity") + -->
<!-- theme_bw() -->
<!-- ``` -->



<!-- ```{r} -->
<!-- iris %>% filter(Species=="versicolor" | Species=="setosa" ) %>% -->
<!-- ggplot( aes(x=Species, y=Sepal.Length, col=)) + geom_violin()+ stat_summary(fun=mean, geom="point", shape=23, size=2, color='red')+theme_bw() -->
<!-- ``` -->



## Opgave (fredag workshop om tidyverse)

Fredag opgave bliver tilgængelige fredag morgen.

## Ekstra links

Cheatsheet: https://github.com/rstudio/cheatsheets/blob/master/data-import.pdf

## Sidste kommentarer








<!-- ### Kombinerer med `full_join` -->

<!-- ```{r} -->

<!-- titanic <- full_join(titanic_train, titanic_test) -->

<!-- ``` -->



<!-- ### `starts_with()`/``ends_with()`/`contains()` -->

<!-- ```{r} -->
<!-- Titanic %>% -->
<!--   data.frame() %>% -->
<!--   select(starts_with("s")) %>% -->
<!--   head() -->
<!-- ``` -->





<!-- Med `titanic_clean` som udgangspunkt lav følgende i samme kommando: -->
<!-- * Benytte `mutate()` til at lav en ny variable `AgeRounded` hvor variablen `Age` er rundet til den nærmeste integer (`round()`). -->
<!-- * Vælg kun personer mellem 20 og 40 år gammel. -->
<!-- * Benytte `group_by()` til at opdele efter `AgeRounded` -->
<!-- * Beregne den gennemsnitlige `Fare` betalt. -->


<!-- ```{r} -->
<!-- titanic_clean %>% -->
<!--   mutate(AgeRounded = round(Age)) %>% -->
<!--   filter(AgeRounded>=20,AgeRounded<=40) %>% -->
<!--   group_by(AgeRounded) %>% -->
<!--   summarise(AveFare = mean(Fare)) %>% -->
<!--   ggplot(aes(x=AgeRounded,AveFare,fill=AgeRounded)) + geom_bar(stat="identity") -->
<!-- ``` -->



<!-- Calculate the survival rate per Class and Sex.  -->
<!-- Which combination of Class and Sex had the highest survival rate? -->

<!-- ```{r} -->
<!-- summary_results = titanic_clean %>% -->
<!--     group_by(Sex,Pclass) %>% -->
<!--     summarise(survival_rate = mean(Survived)) -->
<!-- ``` -->

<!-- ```{r,tidy=FALSE} -->
<!--  titanic_clean %>% -->
<!--     group_by(Pclass) %>% -->
<!--     summarise(meanFare = mean(Fare)) -->
<!-- ``` -->

<!-- Vi kan begynde at være mere fleksibelt med `group_by()` der vi nemt kan lave gruppe over flere variabler, for eksempel ved at se hvor mange passagerer der er efter kombinationen af deres klass og hvor de gik ombord skibet. -->



<!--

```{r}
x <- sample(c("blue","red","orange"),100,prob=c(0.1,0.4,0.5),replace = T)
colour_bag <- tibble("colours"=x)

colour_bag %>% 
  group_by(colours) %>% 
  summarize("count"=n()) %>% 
  mutate(proportion = count/sum(count)) %>%
  ggplot(aes(x=colours,y=proportion,fill=colours)) + 
  geom_bar(stat="identity") +
  scale_fill_manual(values=c("blue","orange","red"))
```

-->