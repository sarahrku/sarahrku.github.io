# Bearbejdning dag 1 {#data}


```{r, echo=FALSE,fig.width = 1,fig.height=1,comment=FALSE,warning=FALSE,out.width="15%"}
# Bigger fig.width
library(png)
library(knitr)
include_graphics("plots/hex-tidyverse.png")
```


## Hvad er Tidyverse?

**Tidyverse** er en samling af pakker i R, som man bruger til at bearbejde datasæt. Formålet er ikke nødvendigvis at erstatte funktionaliteten af base-pakken, men til at bygge på den. Som vi kommer til at se i detaljer, **tidyverse** deler faktisk meget af den samme tankegang bag **ggplot2** - men i stedet for at bruge `+` til at bygge komponenter op i et plot, bruger man `%>%` (udtales 'pipe') til at tilknytte de forskellige funktioner til hinanden.

![Most common tidyverse packages](plots/tidyverse2_packages.png){width=45%}

__Læringsmålene til i dag__

I skal være i stand til at:

* Beskrive generelle hvad R-pakken `Tidyverse` kan benyttes til.
* Beskrive en tibble og genkende når et datasæt er betragtet som "tidy".
* Benytte nogle vigtige `Tidyverse`-verbs til at bearbejde data (`filter()`,`select()`, `mutate()`, `rename()`, `arrange()`, `recode()`).
* Bruge `%>%` til at forbinde `Tidyverse`-verber sammen og at overføre data til et plot.

## Video ressourcer

<!-- * Video 1 - introduktion til uge, hvad er den `tidyverse`-pakke? Hvad er en tibble? -->

<!-- Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/547107062 -->
<!-- ```{r,echo=FALSE} -->
<!-- library("vembedr") -->

<!-- embed_url("https://vimeo.com/547107062") -->
<!-- ``` -->

* __Begynd ved__ at læse "Principper med 'tidy data'" og 'Lidt om tibbles' nedenunder, og så se følgende videoer.

* __Video 1__ - rydde op i datasættet `titanic` med `select()` og `drop_na()`

Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/706266697
```{r,echo=FALSE}
library("vembedr")

#embed_url("https://vimeo.com/546910795") #2021
embed_url("https://vimeo.com/706266697") #2022

```


<!-- * Video 3 - introduktion til `%>%`  -->


<!-- Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/546910781 -->
<!-- ```{r,echo=FALSE} -->
<!-- library("vembedr") -->

<!-- embed_url("https://vimeo.com/546910781") -->
<!-- ``` -->



* __Video 2__ - `tidyverse` verber: `select` og `filter`

Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/705136725
```{r,echo=FALSE}
library("vembedr")

#embed_url("https://vimeo.com/546910758") #2021
embed_url("https://vimeo.com/705136725") #2022
```


* __Video 3__ - flere `tidyverse` verber
  + Lave en ny kolon med `mutate()`
  + Ændre variabelnavne med `rename()`
  + Ændre på værdierne med `recode()` 
  + Ændre rækkefølgen af observationerne med `arrange()`
  + Bruge tidyverse kommandoer som input i `ggplot2()`

Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/706266885
```{r,echo=FALSE}
library("vembedr")

#embed_url("https://vimeo.com/546910712") #2021
embed_url("https://vimeo.com/706266885") #2022

```

## Oversigt over pakker

Lad os starte med at indlæse pakken **tidyverse**. Vær opmærksom på, at har du ikke pakken på din computer, kan det tage lidt tid at installere - det er pga. de mange pakke der **tidyverse** er afhængig af, der enten skal også installeres eller opdateres. __Hvis har pakken installeret men oplever problemer tjek om du har det seneste versioner af pakkerne og R på dit system.__

```{r,warning=F}
#install.packages("tidyverse)
library(tidyverse)
```

Du kan se, at det faktisk er ikke kun én, men otte pakke som er blevet indlæst. Man kan godt indlæse alle pakke individuelt ved at bruge fk. `library(dplyr)`, men det er meget bekvemt at indlæse alle på samme tid med brugen af `library(tidyverse)`. Her er nogle beskrivelser af de pakker:

pakke | korte beskrivelse
--- | ---
`readr` | indlæse data
`ggplot2` | plot data
`tibble` | lave “tibbles” - ***tidyverse***’s svar på datarammer (data.frame).
`tidyr` | skifte imellem data forms (fk. 'long' > 'wide' format, eller omvendt)
`purrr` | functional programming, gentalelse
`dplyr` | manipulere tibbles - beholde delmængder, skabe nye variabler, beregne oversigtsstatistikker osv.
`stringr` | manipulere strings (ikke brugt i dette kursus)
`forcats` | FOR CATegorical data (factors); håndtere faktor variabler

Man kan også indlæse alle pakke individuelt ved at bruge fk. `library(dplyr)`, men det er meget bekvemt bare at indlæse alle på samme tid med brugen af `library(tidyverse)`.

## Principper med 'tidy data'

Idéen bag __tidyverse__ er, at hvis alle datasæt følger præcis den samme struktur, så er det enkelt datasæt ligefrem at bearbejde til præcis som vi gerne vil have det. Datasæt som har den struktur hedder "tidy data". For at betragte et datasæt som "tidy", må det opfylde tre kriterie:

* Hver variabel i datasættet har sin egen kolonne
* Hver observation i datasættet har sin egen række
* Hver værdi i datasættet få sin egen cell

Iris er et godt eksempel af **tidy data**:

```{r}
data(iris)
head(iris)
```

Hver variabel (`Sepal.Length`, `Sepal.Width`, `Petal.Length`, `Petal.Width` og `Species`) har sin egen kolon, og hver observation (e.g. 1,2,3, osv.) har sin egen række. Derudover har hver cell sin egen data værdi og det er dermed meget klart at læse og forstå dataframen ved øjnene. 

![Principper af tidy data](plots/tidy-1.png){width=100%}

Det er tilfældet, at de fleste af datasæt i dette kursus hører til "tidy data", især i disse notater, hvor vi benytter en del af indbygget datasæt. Nogle gange kan det dog være, at vi er nødt til at gøre noget, til at lave et datasæt om til en "tidy datasæt". R-pakker **dplyr** og **tidyr** er velegnet til at hjælpe med at transformere et datasæt til en, der er "tidy", og bagefter kan man forsætte i den sædvanlige måde med at analyse datasættet. Bemærk at bare fordi et datasæt er "tidy", betyder det ikke nødvendigvis, at det er klart til at analysere, for der kan godt være, at man har bruge for at bearbejde videre på det første - igen med pakkerne **dplyr** og **tidyr**.

## Lidt om `tibbles`

En `tibble` er det `tidyverse` svar på en `data.frame` fra base-R. De ligner hinanden meget og derfor behøver man ikke tænk for meget over forskellen, men der er nogle opdateret aspekter i en `tibble` - for eksempel bruger en `tibble` ikke `row.names`, og når man visualiserer en `tibble` i R Markdown, få man lidt ekstra oplysninger, såsom dimensioner og data typer. Bemærk, at de fleste `tidyverse` funktioner fungerer lige så godt uanset om man har en `tibble` eller en `data.frame`. Bemærk, at jeg vedligeholder ordet 'dataframe' indenfor almindelig tekst.

Man kan lave sin egen `tibble` på samme måde som en `data.frame`.

```{r}
tibble(x=1:3,y=c("a","b","c"))
```

Man kan også lave en `tribble`, som er den samme som en `tibble` men har en lidt anderledes måde at indsætte data på. For eksempel er følgende tilsvarende til den overstående tibble:

```{r}
tribble(~x, ~y,
       1, "a",
       2, "b",
       3, "c")
```

Man kan lave en `data.frame` om til en `tibble` som i følgende:

```{r}
as_tibble(iris)
```

__De fleste `tidyverse` koder fungerer lige så godt uanset om man har en `tibble` eller en `data.frame`. __

## Transition fra base til tidyverse

Jeg introducerer **tidyverse** gennem et meget berømt datasæt som hedder **titanic** - det er ikke biologiske data men er stadigvæk ret interessant, og sjovt at manipulere på. 

**titanic** er brugt som en del af en åben konkurrence på hjemmesiden Kaggle, hvor mindst 31.000 personer indtil videre har arbejdet på at lave den bedste model til at forudsige, hvem der overlever katastrofen - linket er her, hvor du kan også læse om baggrunden til datasættet https://www.kaggle.com/c/titanic. 

### Om **Titanic** datasæt

Man kan downloade datasættet, der hedder `titanic_train`, direkte fra Kaggle, men der er faktisk en R-pakke, der hedder `titanic` som gøre det mere bekvemt:

```{r}
#install.packages("titanic") #hvis ikke allerede installerede
library(titanic)
```

Her er beskrivelsen for pakken:

_**titanic** is an R package containing data sets providing information on the fate of passengers on the fatal maiden voyage of the ocean liner "Titanic", summarized according to economic status (class), sex, age and survival. These data sets are often used as an introduction to machine learning on Kaggle._

Vi vil gerne bruge `titanic_train` fordi det er datasættet, der bliver brugt på Kaggle til at træne maskinelærings modeller (som bliver testet på `titanic_test` for at evaluere, hvor god modellen er). Til at gøre tingene nemmere, lad os bare omdøb `titanic_train` til `titanic` og anvende `glimpse`, der er fra pakken `dplyr`, på datasættet.

```{r}
titanic <- as_tibble(titanic_train)
glimpse(titanic)
```

Jeg har også kopieret de variable beskrivelser her:

* PassengerId: unique index for each passenger
* Survived: Whether or not the passenger survived. 0 = No, 1 = Yes.
* Pclass: Ticket class: 1 = 1st Class, 2 = 2nd Class, 3 = 3rd Class.
* Name: A character string containing the name of each passenger.
* Sex: Character strings for passenger sex ("male"/ "female").
* Age: Age in years.
* SibSp: The number of siblings/spouses aboard the titanic with the passenger
* Parch: The number of parents/children aboard the titanic with the passenger
* Ticket: Another character string containing the ticket ID of the passenger.
* Fare: The price paid for tickets in pounds Sterling (Keep in mind that unskilled workers made around 1 pound a week - these were expensive tickets!)
* Cabin: The cabin number of the passengers (character).
* Embarked: Where passengers boarded the titanic. C = Cherbourg, Q = Queenstown, S = Southampton).

### Titanic: oprydning

Der er faktisk nogle rengøring i datasættet vi skal tage os af, før vi kan komme videre med analysen. Vi kan se fra `glimpse(titanic)` ovenpå at der er 891 observationer. De fleste (687) passagerer har faktisk ingenting for variabel `Cabin`:

```{r}
sum(titanic$Cabin=="") #ingenting for variabelen 'cabin'
```

Andre har mere end én cabin. Det ser ikke særlig **tidy** ud, og man kan hellere ikke forestille sig at få meget insigt fra variablen, så vi vælger at fjerne hele kolon med funktionen `select()`:

```{r}
titanic_no_cabin <- select(titanic, -Cabin) 
```

`select()` er en af de kerne funktioner i **tidyverse** - her angiver vi, hvilke kolonner vi gerne vil beholde eller fjerne fra datasættet. I dette tilfælde har vi specificeret `-Cabin`, som betyder, at vi _ikke_ vil have variablen `Cabin` med, men gerne vil beholde resten af kolonnerne. Prøv selv at køre `select(titanic, Cabin)` i stedet for - så får vi kun `Cabin` og fjerner resten af vores variabler.  

```{r}
glimpse(titanic_no_cabin)
```


Næste tjekker vi efter `NA` i datasættet. `NA` er hvordan R betegner manglende værdier. Man kan se i følgende, mens de fleste variabler ikke har `NA` værdier, har variablen `Age` 177 `NA`. 


```{r}
colSums(is.na(titanic_no_cabin))
```

I dette tilfælde vælger jeg at fjerne alle passagerer som har `NA` i stedet for deres alder. Til dette formål bruger jeg funktionen `drop_na`, som fjerner alle observationer, der har `NA` i mindst èn variabel.

```{r,tidy=FALSE}
titanic_clean <- drop_na(titanic_no_cabin)
colSums(is.na(titanic_clean))
```

Nu kan vi tjekke igen, hvor mange observationer og variabel vi har tilbage.

```{r}
glimpse(titanic_clean)
```

Vi har beholdt 714 observationer og 11 variabler, og datasættet opfylder kriteren for at være **tidy**.

### Pipe

Man kan faktisk gøre den samme som i ovenstående ved at bruge pipe `%>%`:

```{r,tidy=FALSE}
titanic_clean <- titanic %>% # we take the titanic dataset
    select(-Cabin) %>% # select the bits we want
    drop_na() # then remove the NAs
```

Man bruger pipe `%>%` til at kombinere adskillige tidyverse funktioner i den samme kommando - linjen slutter med `%>%`, der fortæller, at vi skal bruge resultatet fra den linje som inputtet i den næste linje. Logikken er således, at vi starter med en dataframe, gør dernæst én ting ad gangen, og så slutter med en ny dataframe (som vi kan gemme med `<-`). 

Bemærk, at processen ligner den, man bruger i **ggplot2**, men forskellen er at man bruger `%>%` i stedet for `+` i denne ramme. Bemærk også her, at ligesom i **ggplot2**, skriver jeg koden over flere linjer. Det er ikke et krav men det gøre det nemmere at læse og forstå koden.

For at illustrerer logikken, kan man se, at følgende to linjer er tilsvarende:

```{r,tidy=FALSE,eval=FALSE}
#take x and apply some function f
f(x)    #traditional approach
x %>% f #tidyverse approach
```

I begge tilfælde starter vi med `x`, og så anvender vi funktionen `f` med `x` som argument - en kæmpe fordel med den tidyverse løsning er, at når man har flere funktioner, slipper man for at anvende mange parenteser, og rækkefølgen man skriver funktionerne læses fra venstre til højre og ikke omvendt, se for eksempel følgende:

```{r,tidy=FALSE,eval=FALSE}
#take x, apply f, then apply g, then apply h
h(g(f(x)))          #traditional approach
x %>% f %>% g %>% h #tidyverse approach
```

På sammen måde i vores titanic oprydning kan man både pakke funktionen `select()` ind i funktionen `drop_na()`, eller bruge den **tidyverse** løsning, ligesom i nedenstående - de to giver det tilsvarende resultat: første bruger vi `select()` til at fjerne kolonnen `Cabin`, og så bruger vi `drop_na()` til at fjerne alle række med mindste én `NA` .

```{r,eval=FALSE,tidy=FALSE}
titanic_clean <- drop_na(select(titanic,-Cabin))

titanic_clean <- titanic %>% 
    select(-Cabin) %>%
    drop_na() 
```

## Bearbejdning af data: `dplyr`

Pakken `dplyr` er nok den meste brugbare pakke til at bearbejde dataframes. Jeg gennemgår nogle af de meste almindelige muligheder med pakken, og der er også en "cheatsheet" som du kan downloade som reference: https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf. Jeg tager afsæt i følgende funktioner, og dækker flere gennem de forskellige øvelese og øvrige emner.

dplyr verbs | beskrivelse
--- | ---
`select()` | udvælge kolonner (_variabler_) 
`filter()` | udvælge rækker (_observationer_)
`arrange()` | sortere rækker
`mutate()` | tilføje eller ændre eksisterende kolonner
`rename()` | ændre variabler navne
`recode()` | ændre selve data
`group_by()` | dele datasættet op efter en variabel
`summarise()` | aggregere rækker, findes ofte tilknyttet til `group_by()` 

Bemærk, at alle disse funktioner tager udgangspunkt i en dataframe, og man får altid en ny dataframe som outputtet. Ved at kunne bruge disse funktioner og kombinere dem (ved hjælp af `%>%`), har man godt styr på bearbejdningen af datarammer.

###  dplyr verbs: `select()`

Som vi lige har set i ovenstående, med `select()` udvælger man bestemte __variabler__. Vi kan vælger at beholde, fjerne eller andre rækkefølgen af variablerne i dataframe. Som eksempel, her beholder vi kun variablerne `Name` og `Age`:

```{r}
titanic_clean %>% 
  select(Name, Age) %>%
  glimpse()
```

Hvis vi gerne vil fjerne en variabel fra en dataframe, kan vi bruge et minustegn. I nedenstående fjerner vi `Name` og `Age` fra dataframe:

```{r}
titanic_clean %>% 
  select(-Name, -Age) %>%
  glimpse()
```

#### Hjælper funktioner til `select()`

Hjælper funktioner til funktionen `select()` kan være brugbare hvis du gerne vil udvælge bestemte variabler efter nogle kriterier. Jeg har samlet nogle (men ikke alle mulige!) funktioner nedenfor og inddrager eksempler i problemstillingerne.

select helper | beskrivelse
--- | ---
`starts_with()` | starts with a prefix
`ends_with()` | ends with a prefix
`contains()` | contains a literal string
`matches()` | matches a regular expression
`num_range()` | a numerical range like x01, x02, x03.
`one_of()` | variables in character vector.
`everything()` | all variables.
`where()` | fk. takes a function and returns all variables for which the function returns TRUE:

For eksempel:

```{r}
titanic_clean %>% select(starts_with("P"))
```

Særligt brugbar i statistik statistisk metoder der kræver kun numeriske variabler er `where()` når kombinerede med `is.numeric`. Eksempelvis i følgende kode udvælger man kun numeriske variabler fra datasættet `titanic_clean`: 

```{r}
titanic_clean %>% select(where(is.numeric))
```


### dplyr verbs: `filter()`

Med funktionen `select()` udvælger man bestemte __variabler__. Man anvender til gengæld funktionen `filter()` til at udvælge bestemte __observationer__ (rækker) fra dataframe. I nedenstående beholder jeg rækkerne, hvor variablen `Age` er lig med 50. Bemærk, at vi bevarer alle variabler i dataframe.

```{r}
titanic_clean %>% 
  filter(Age == 50) %>%
  glimpse()
```

Man kan også vælge intervaller - for eksempel hvis man vil vælge alle som er i halvtredserne. 

```{r}
titanic_clean %>% 
  filter(Age >= 50 & Age < 60) %>%
  head()
```

Man kan også kombinere betingelser fra forskellige kolonner, for eksempel i nedenstående vælger vi alle personer som er kvinder __og__ som rejste ved første klasse. 

```{r}
titanic_clean %>% 
    filter(Sex == 'female' & Pclass == 1) %>%
    head()
```

Vi kan også inddrage flere symboler. For eksempel i nedenståenden  vælger vi personer som er kvinder __og__ som rejste i __enten__ første eller anden klass __og__ som er __i__ trediverne. Huske at tilføje runde parenteser omkring de to `Pclass` - prøv selv at fjerne dem og se, hvad der sker. 

```{r}
titanic_clean %>% 
    filter(Sex == 'female' & (Pclass == 1 | Pclass == 2) & Age %in% c(30:39)) %>%
    glimpse()
```


### Comparitiver reference

Her er en tabel af comparitiver (kopirede fra grundlæggende R) - de er brugbare i både `filter()` og i baseR (fordi koncepten bag er den samme, bare tilgang er ænderledes).

comparitive | beskrivelse
--- | ---
`<` | less than
`>` | greater than
`<=` | less than or equal to
`>=` | greater than or equal to
`==` | equal to
`!=` | not equal to
`&` | and 
`%in%` | in
`|` | or

### Kombinere `filter()` og `select()`

Man kan også kombinere både `filter()` og `select()` i samme kommando, som i følgende:

```{r}
titanic_clean %>% 
    filter(Sex == 'female' & (Pclass == 1 | Pclass == 2) & Age %in% c(30:39)) %>%
    select(Name, Fare)  %>% 
    glimpse()
```

Bemærk at man bør passe på rækkefølgen, som man anvender de forskellige funktioner. For eksempel hvis man bytter rundt `filter()` og `select()` i ovenstående, få man en advarsel - prøv selv at køre følgende: 

```{r,eval=FALSE,tidy=FALSE,warning=FALSE}
##virker ikke!!!!!#####
titanic_clean %>% 
    select(Name, Fare)  %>% 
    filter(Sex == 'female' & (Pclass == 1 | Pclass == 2) & Age %in% c(30:39)) %>%
    glimpse()
```

Det er fordi, hvis man første vælger at beholde variablerne `Name` og `Age`, så findes de andre variabler ikke mere i de resulterende dataframe, som bliver dernæst brugt i funktionen `filter()` - man kan derfor ikke benytte funktionen `filter()` på variablerne `Pclass`,`Sex` og `Age`.

### dplyr verbs: `mutate()`

Man kan avende funktionen `mutate()` til at tilføje en ny variable til en dataframe. I nedenstående tilføjer jeg en ny variabel med navnet `Adult`, der angiver om personen kan betragtes som en voksen (hvis vedkommende er mindst 18 år gammel). 

```{r}
titanic_with_Adult <- titanic_clean %>% 
    mutate(Adult = Age>=18)

titanic_with_Adult %>% select(Adult) %>% glimpse 
```

#Så kan man se, at der er `r sum(titanic_with_Adult$Adult)` voksne og `r sum(!titanic_with_Adult$Adult)` børn som passagerere på skibet.

Bemærk her, at jeg gemmer resultatet som en ny dataframe, der hedder `titanic_with_Adult`, og derefter bruger jeg `glimpse()` på det nye objekt `titanic_with_Adult` for at se, hvordan min nye dataframe ser ud. I forudgående eksempler havde jeg ikke gemt resultatet - bare brugt `glimpse()` for at se resultatet på skærmen. __Hvis du gerne vil bruge din resulterende dataframe videre, så skal du husk at gemme den (med brugen af `<-` tegn)__

__funktionen `ifelse()` indenfor `mutate()`__

Jeg kan oprette variablen `Adult` sådan at den er mere informativ end bare `TRUE` eller `FALSE`. Jeg anvender funktionen `ifelse()`, der giver mulighed for at angive, at jeg gerne vil have teksten "adult" hvis udsagnet `Age>=18` er TRUE, og hvis FALSE vil jeg have teksten "child":

```{r,eval=F,echo=T}
ifelse(Age>=18,"adult","child")
```

Fuktionen `ifelse()` bruges indenfor funktionen `mutate()`, fordi vi er i gang med at oprette en ny variable `Adult` - `ifelse()` giver bare mulighed for at fortælle, hvordan den nye variablen skal ser ud.

<!-- mere informativ Adult kolonne -->
```{r}
titanic_clean %>% 
    mutate(Adult = ifelse(Age>=18,"adult","child")) %>%
    select(Age,Adult) %>%
    glimpse()
```

Så er variablen lidt mere informativ end før.

###  `rename()`

Man kan bruge `rename()` til at ændre navnet på en eller flere variabler i datasættet. Som eksempel bruger jeg `rename()` til at give en variable navnet `Years` i stedet for `Age` (bemærk at variablen `Age` findes ikke længere).

```{r}
titanic_clean %>%
  rename(Years = Age) %>%
  glimpse()
```

Man kan også ændre navne på flere kolonner samtidigt - for eksempel, i følgende laver jeg nogle oversættelsesarbejde:

<!-- Ændre navne på flere kolonner på én gang -->
```{r}
titanic_clean_dansk <- titanic_clean %>%
  rename(Overlevede = Survived,
         Navn = Name,
         Klasse = Pclass)
```

Så du kan se, at jeg har ændrede de variabler navne. Jeg kalder den nye dataframe for `titanic_clean_dansk`, så jeg min danske udgave er blevet gemt et sted.

Man kan også gøre sådan, at man har kun små bogstaver i de variabler navne. Jeg benytter den danske version, og Jeg anvender `rename_with()` og specificerer `tolower`.

<!-- Ændre navne til små bogstaver -->
```{r}
titanic_clean_dansk %>%
  rename_with(tolower)  %>% #all variable names are lower case only
  glimpse() 
```

Prøv også at erstatte `tolower` med `toupper`.

### dplyr verbs: `recode()`

Med `recode()` kan man ændre hvordan en variable ser ud - fk. male/female kan ændres til 0/1, som i følgende.

```{r} 
 titanic_clean %>%
   mutate(Sex = recode(Sex,  "male" = 0, "female" = 1)) %>%
   select(PassengerId,Name,Sex) %>% glimpse()
```

Bemærk den måde, at funktionen `recode()` er blevet brugt indenfor funktionen `mutate()`: jeg lavede en ny variable af samme navn, men med ændret værdier indenfor variablen.

Hvis vi gerne vil skifter omvendt fra 0/1 til male/female er vi nødt til at skrive ``1`` / ``0`` for at specificie at vi har værdier som er tal, og vi gerne vil kalde dem for nogle andet ("male"/"female" i dette tilfælde):

```{r} 
#recodes variable Sex and then recodes it back to original form again
 titanic_clean %>%
   mutate(Sex = recode(Sex,  male = 1, female = 0)) %>%
   mutate(Sex = recode(Sex,  `1` = "male", `0` = "female")) %>% #note use of `` in the numbers 
   select(PassengerId,Name,Sex) %>% glimpse()
```


###  dplyr verbs: `arrange()`

Man anvender `arrange()` for at vælge rækkefølgen på observationerne. I nedenstående tager vi datarammen `titanic_clean` og arrangerer observationer efter variablen `Fare`. Det sker således at, personer som betalt mindst er på toppen af de resultarende dataramme, og personer som betalt mest er på bunden.

```{r}
# Arrange by increasing Fare
titanic_clean %>%
  arrange(Fare) %>%
  glimpse()
```

Hvis man gerne vil få det omvendt - at personer som betalt mest er på toppen af datarammen, kan man bruge `desc()` omkring `Fare`, som i nedenstående:

```{r}
# Arrange by decreasing Fare
titanic_clean %>%
  arrange(desc(Fare)) %>%
  glimpse()
```


## Visualisering: bruge som input i ggplot2

Efter man har lavet bearbejdning med tidyverse kommandoer, kan man specificere de resulterende dataframe som data i funktionen `ggplot()`. Man benytter `%>%` til at forbinde de `dpylr` kommandoer med den `ggplot` funktion, og I dette tilfælde behøver man ikke at angive navnet på datasættet indenfor funktionen `ggplot`. I nedenstående eksempel tager jeg udgangspunkt i `titanic_clean` og så laver jeg et barplot som viser antallet af passagerer som rejste i hver af de tre klass.

<!-- Tag titanic_clean og lave et barplot -->
```{r,fig.width=3,fig.height=4}
titanic_clean %>% 
  ggplot(aes(x=Pclass,fill=as.factor(Pclass))) + 
  geom_bar(stat="count") +
  theme_minimal()
```

Jeg gør det lidt mere kompliceret i følgende, ved at tage `titanic_clean`, lave en ny kolon der hedder `Adult`, og så bruge den resulterende dataframe med funktionen `ggplot`, hvor jeg laver et plot med `Adult` på x-aksen for at tælle op antallet af voksne og børn.

<!-- Lave Adult kolon og lave et barplot -->
```{r,fig.width=3,fig.height=4}
titanic_clean %>% 
   mutate(Adult = ifelse(Age>=18,"Adult","Child")) %>% 
   ggplot(aes(x=Adult,fill=Adult)) + 
   geom_bar(stat="count") + 
   theme_minimal()
```

Så viser det, at der var 600 Adults og lidt over 100 Children ombord skibet.

## Misc funktioner som er nyttige at vide

### Pull

I tidyverse arbejder vi meget med dataframes - tilgagen er således at man tager udgangspunkt i en dataframe, får en dataframe som resultat og så arbejde videre på den dataframe. Nogle gange kan det dog være at man gerne vil udtrække en variabel som vector fra en dataframe, fk. hvis man gerne vil bruge den i en bestemt statistik metode.

Se følgende eksempel, hvor man udtrække variable `Age` for "male" og "female" (variablen `Sex`) og bruge resulterende vectorer i en t-test sammenhæng: 

```{r}
ages_male <- titanic_clean %>% filter(Sex=="male") %>% pull(Age)
ages_female <- titanic_clean %>% filter(Sex=="female") %>% pull(Age)
t.test(ages_male,ages_female)
```

Så kan man se at mænd og kvinder har signifikant forskellige alder i gennemsnit (hvor mændene er ældre en kvinderne).

### Slice

Med funktionen `Slice` kan man kigge på nogle bestemte observationer, for eksempel, viser følgende de to passagerer der betalt mest for billeten (variable `Fare`).

```{r}
titanic %>% 
  arrange(desc(Fare)) %>%
  select(Name,Age) %>% 
  slice(1,2)
```
Se udvidet muligheder her: https://dplyr.tidyverse.org/reference/slice.html

## Problemstillinger

__Problem 1__) Lav quizzen på Absalon - "Quiz - tidyverse - part 1"

---

*Vi øver os med titanic. Inlæs datasættet og lav overstående oprydningen med følgende kode:*

```{r,echo=TRUE,eval=FALSE,comment=FALSE,message=FALSE,warning=FALSE}
library(tidyverse)
library(titanic)
titanic <- as_tibble(titanic_train)

titanic_clean <- titanic %>% 
    select(-Cabin) %>% 
    drop_na() %>% 
    mutate(Adult = ifelse(Age>=18,"adult","child")) %>%
    mutate(Survived = recode(Survived,  `1` = "yes", `0` = "yes")) 
    
glimpse(titanic_clean) #take a look!

#recode embarked so we have the place names
#include ifelse and count
```

<!-- `count()` Tæller op observationer. -->

<!-- ```{r} -->
<!-- titanic %>% -->
<!--   filter(Sex %in% c("female","male")) %>% -->
<!--   count(Sex) %>% -->
<!--   head() -->
<!-- ``` -->

---

__Problem 2__) `select()`. Fjern variablen `Name` fra `titanic_clean` (du behøver ikke at gemme din nye dataframe).


```{r,tidy=FALSE,echo=TRUE,eval=FALSE}
titanic_clean %>% 
    select(...) #redigere her
```

```{r,tidy=FALSE,echo=FALSE,eval=FALSE}
titanic_clean %>% 
    select(-Name)
```

* Tilføj også `glimpse()` for at se et overblik (man kan også bruge `head()`)

---

__Problem 3__) `select()`. Lave en ny dataframe fra `titanic_clean` med kun variabler `Name`, `Pclass` og `Fare`.

```{r,tidy=FALSE,echo=FALSE,eval=FALSE}
titanic_clean %>% 
    select(Fare,Pclass,Name)
```

* Gør det en forskel, hvilke rækkefølger man skriver `Name`, `Pclass` og `Fare`?

---

__Problem 4__) _`select()` og hjælper funktoner_. I stedet for at specificere bestemt kolonner navn, skriv `starts_with("S")` indenfor `select()`. Hvad sker der?

```{r,tidy=FALSE,echo=FALSE,eval=FALSE}
titanic_clean %>% 
    select(starts_with("S"))
```

* Prøv også `contains("ar")`

```{r,tidy=FALSE,echo=FALSE,eval=FALSE}
titanic_clean %>% 
    select(contains("ar"))
```

* Prøv også `-any_of(c("Survived","Pclass","FavouriteColour"))` og `-all_of(c("Survived","Pclass","FavouriteColour")`
  + i tilfældet af `all_of` skal alle variablerne i vectoren `c("Survived","Pclass","FavouriteColour")` være i datasættet, ellers får man en advarsal.
  + i tilfældet af `any_of` gælder det alle variabler fra vectoren `c("Survived","Pclass","FavouriteColour")` der er i datasættet, og resten bliver ignoreret. 

```{r,tidy=FALSE,echo=FALSE,eval=FALSE}
titanic_clean %>% 
    select(-any_of(c("Survived","Pclass","FavouriteColour")))
```

* Prøv også `matches("^S[i|u]")` - kan du gisner på hvad det betyder (se nedenunder)?

```{r,tidy=FALSE,echo=FALSE,eval=FALSE}
titanic_clean %>% 
    select(matches("^S[i|u]"))
```

---

<!-- __Problem 5__) `filter()`. Lave en ny dataframe fra `titanic_clean` med alle personer som er `male` __og__ over 30 år gammel. -->


<!-- ```{r,echo=FALSE,eval=FALSE} -->
<!-- titanic_clean %>%  -->
<!--   filter(Sex=="male" & Age>30) %>% -->
<!--   glimpse() -->
<!-- ``` -->


<!-- --- -->


__Problem 5__) `filter()`. Lave en ny dataframe fra `titanic_clean` med alle passagerer som er mellem 10 og 15 og rejst enten første eller anden klass. 


```{r,echo=FALSE,eval=FALSE}
titanic_clean %>% 
  filter(Age>=10 & Age<=15 & (Pclass==1 | Pclass==2)) %>%
  glimpse()
```

* Prøv at tilføje `%>% count()` til kommandoen - Hvor mange observationer er der i den nye dataframe?

```{r,echo=FALSE,eval=FALSE}
titanic_clean %>% 
  filter(Age>=10 & Age<=15 & (Pclass==1 | Pclass==2)) %>% 
  count()
```

---
    
__Problem 6__) *`filter()` og `select()` : kombinering med `%>%`* 

Lave en ny dataramme fra `titanic_clean` med alle passagerer som er "male" og overlevede (variablen `Survived` er "yes"), og udvælg kun kolonner `Name`, `Age` og `Fare`.

```{r,echo=FALSE,eval=FALSE}
titanic_clean %>% 
     filter(Sex=="male" & Survived=="yes") %>% 
     select(Name,Age,Fare)
```


---

__Problem 7__) *`filter()` og `select()` kombinering med `%>%`* 

Lave en ny dataramme fra `titanic_clean` med kun variabler `Name` og `Age` og dernæst specificere kun de passagerer som er over 60.

```{r,echo=FALSE,eval=FALSE}
titanic_clean %>% 
     select(Name,Age) %>% 
     filter(Age>60)
```

* Få man så den samme sæt observationer hvis du skriver dine `select()` og `filter()` funktionerne omvendt her? Hvorfor?

```{r,echo=FALSE,eval=FALSE}
titanic_clean %>% 
     filter(Age>60) %>%
     select(Name,Age)
```

---

__Problem 8__) *`Mutate()`*. Lave en ny dataframe fra `titanic_clean` som hedder `FareRounded` og viser `Fare` rundet til det nærmest integar (hint: benyt funktionen `round()`).


```{r,echo=FALSE,eval=FALSE}
titanic_clean %>%
    mutate(FareRounded = round(Fare))
```

---

__Problem 9__) *`Mutate()`* og *`ifelse()`*. Lave en ny dataramme fra `titanic_clean` med en ny kolon som hedder `Family` som angiver `TRUE` hvis `Parch` er ikke nul, ellers `FALSE`.

```{r,echo=FALSE,eval=FALSE}
titanic_clean %>% mutate("Family"=Parch>0)
```

* Anvende `ifelse` til at gøre variablen mere intuitiv - "Family" og "Not family".

---

__Problem 10__) *`Mutate()`* og *`ifelse()`*

Kig en gang til på beskrivelsen af følgende to variabler i datasættet:

_`SibSp`: The number of siblings/spouses aboard the titanic with the passenger_

_`Parch`: The number of parents/children aboard the titanic with the passenger_

* Lav en ny variabel `Solo` som viser "Yes" hvis passageren rejste alene, og "No" hvis passageren rejste med andre.
* Brug `mutate` igen til at lave den nye variabel om til at være en factor.
* Gem også dit output (som `titanic_clean` igen) så du kan bruge din nye variable videre i næste spørgsmål. 

```{r,echo=TRUE,eval=FALSE}
titanic_clean <- titanic_clean %>%  ... 
```


```{r,echo=FALSE,eval=TRUE}
titanic_clean <- titanic_clean %>%  mutate(Solo = ifelse(SibSp + Parch == 0, "Yes", "No"),
                          Solo = as.factor(Solo))
```

---

__Problem 11)__ *pull() og t.test()* Betalte passagererne der rejste alene (variablen `Solo` fra sidste problem) den samme i gennemsnit for deres billet (variablen `Fare`) end passagererne der ikke rejste alene? Lav et t.test (anvend `pull()` til at udtrække hensigtsmæssige vectorer - se også eksempel i kursusnotaterne)

```{r}
t.test(titanic_clean %>% filter(Solo=="Yes") %>% pull(Fare),
       titanic_clean %>% filter(Solo=="No") %>% pull(Fare) )
```


__Problem 12__) *`Recode()`* I variablen `Embarked`:

* C står for Cherbourg
* Q står for  Queenstown
* S står for Southampton

__a__) Anvend `recode` (indenfor `mutate`) til at ændre værdierne i variablen `Embarked` således at man får de fulde navne af de steder folk gik ombord skibet, i stedet for kun den første bogstav. Gem også dit output (som `titanic_clean` igen) så du kan bruge din nye variable videre. 

```{r,echo=F,eval=T}
titanic_clean <- titanic_clean %>% 
  mutate(Embarked = recode_factor(Embarked,S = "Southampton",
                                           Q = "Queenstown",
                                           C = "Cherbourg"))
```

__b__) Erstat `recode` med `recode_factor` og sammenlign datatypen af variablen `Embarked` i din nye dataframe.

__c__) Prøv at tilføje funktionen `count()` for at tælle op hvor mange gik om bord i de forskellige steder.

* Prøv også med to variabler indenfor `count()` - `Solo` og `Embarked`

Resultatet ser sådan ud:

```{r,echo=F}
titanic_clean %>% count(Solo,Embarked)
```

__d__) Man kan se, at der er to passagerer hvor der ikke er noget skrevet i `Embarked`.
  + Rejste de alene?
  + Lav en ny dataframe med de to passagerer fjernet fra datasættet.

---

__Problem 13__) *`Arrange()`*. Lave en ny dataramme fra `titanic_clean` med observationerne arrangerede således at de yngst er på toppen og ældste er på bunden. Kig på resultatet - hvad kan du fortælle om den yngste passager ombord skibet Titanic?

```{r,eval=FALSE,echo=FALSE}
titanic_clean %>% 
  arrange(Age)
```

* Hvad kan du fortælle om den ældste passager ombord skibet? Overlevede de? Hvad med de andre ældste passagerer?

```{r,eval=FALSE,echo=FALSE}
titanic_clean %>% 
  arrange(desc(Age))
```

---

__Problem 14__)  *`Arrange()` og kombinering med andre verber*. Lave en ny dataramme fra `titanic_clean` med kun personer med `SibSp>0` og som gik ombord skibet i Southampton, arrangere de resulterende observationer efter `Fare` (højeste på toppen) og udvælg kun kolonnerne `Name`, `Age` og `Fare`.

```{r,eval=FALSE,echo=FALSE}
titanic_clean %>% 
  filter(SibSp>0 & Embarked=="Southampton") %>%
  arrange(desc(Fare)) %>%
  select(Name,Age,Fare)
```


---

__Problem 15__) *Rename*. Fra `titanic_clean` udvælg kun variabler `Survived`,`Ticket`, og `Name` og ændre deres navne til `Overlevede`, `Billet` og `Navn`.  

* Gør variabler navne til store bogstaver ved at anvende `rename_with()`.

---


__Problem 16__) *Lave et plot*. Fra `titanic_clean` bruge `filter()` til at lave en ny dataramme kun med personer under 30 og bruge den til at lave et barplot som viser antallet af personer opdelt efter Pclass. Bruge følgende struktur for koden:

```{r,eval=FALSE,echo=TRUE}
titanic_clean %>% 
  filter(...) %>% #rediger linjen
  ggplot(aes(...)) + .... #tilføj plot
```

---

__Problem 17__) *Lave et plot*. Fra `titanic_clean`, bruge `mutate()` til at lave et nyt kolon der hedder `with_siblings_spouses` der er `TRUE` hvis `SibSp` ikke er nul. Brug den til at lave boxplots som viser `Fare` på y-aksen og `with_siblings_spouses` på x-aksen.

```{r,eval=FALSE,echo=FALSE}
titanic_clean %>%
  mutate(with_siblings_spouses=SibSp>0) %>% 
  ggplot(aes(x=with_siblings_spouses,y=Fare,fill=with_siblings_spouses)) + 
  scale_y_continuous(trans="log2") +
  geom_boxplot() + theme_minimal()
```

* Ekstra: Ændre skalen på y-aksen for at gøre plottet klarer at fortolke.

## Kommentarer

* `matches("^S[i|u]")` betyder
  + `^S` variabel navn skal starter med en S
  + `[i|u]` den næste bogstav i variabel navnet skal være enten i eller u
* OBS det er ikke vigtigt at lære pattern matching i kurset men det er meget brugbart i andre sammenhænge!

Næste gange arbejder vi videre med tidyverse.

* Group_by kombinerede med Summarise
* Pivot_Longer/Pivot_Wider
* Join funktionerne