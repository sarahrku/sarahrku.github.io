# Visualisering - ggplot2 dag 2 {#visual2}

```{r, echo=FALSE,fig.width = 3,fig.height=3}
# Bigger fig.width
library(jpeg)
library(knitr)
include_graphics("plots/ggplot2_logo.jpeg")
```

## Indledning og videoer

I nuværende emne udvider du værktøjskassen af kommandoer i pakken __ggplot2__ for at tillade større fleksibilitet og appel i dine visualiseringer. Jeg anbefaler, at du ser videoerne inden undervisningstimerne og bruger notaterne som en slags reference samtidig at du arbejder med problemstillingerne.

### Læringsmålene

I skal være i stand til at:

* Arbejde fleksibelt med koordinat systemer - transformering, modificering og "flipping" af x- og y-aksen.
* Udvide brugen af farver og form.
* Tilføje tekst direkte på plottet med `geom_text()`.
* Bruge `facet_grid()` eller `facet_wrap()` til at adskille plots efter en katagorisk variabel.
* Gemme dit færdigt plot i en fil.

<!-- * Gemmme det færdigt plot i en fil. -->

```{r}
library(ggplot2) #husk
```

### Video ressourcer

* Video 1: Koordinat systemer (2021)

Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/544201985
```{r,echo=FALSE}
library("vembedr")

embed_url("https://vimeo.com/544201985")
```

* Video 2: Farver og punkt former (2021)

Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/544218153
```{r,echo=FALSE}
library("vembedr")

embed_url("https://vimeo.com/544218153")
```

* Video 3: Labels - `geom_text()` og `geom_text_repel()` (2021)

Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/544226498
```{r,echo=FALSE}
library("vembedr")

embed_url("https://vimeo.com/544226498")
```


* Video 4 - Facets

Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/704140333
```{r,echo=FALSE}
library("vembedr")

embed_url("https://vimeo.com/704140333")
```


## Koordinat systemer

Her arbejder vi videre med koordinater i pakken __ggplot2__.

### Zoom (`coord_cartesian()`, `expand_limits()`)

Man kan bruge funktionen `coord_cartesian()` til at zoome ind på et bestemt område i plottet. __Indenfor__ `coord_cartesian()` angives `xlim()` og `ylim()`, som specificerer de øvre og nedre grænser langt henholdsvis x-aksen og y-aksen. Man kan også bruge `xlim()` og `ylim()` udenom `coord_cartesian()`, men i dette tilfælde bliver punkterne, som ikke kan ses i plottet (fordi deres koordinater ligger udenfor de angivne grænser), smidt væk (med en advarsel). Med `coord_cartesian()` beholder man til gengæld samtlige data, og man får således ikke en advarsel.

I følgende ses vores oprindeligt scatter plot:

```{r,fig.width=5,fig.height=4}
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width,color = Species)) +
  geom_point() + 
  theme_minimal() 
```

Og her anvender jeg funktionen `coord_cartesian()` med `xlim()` og `ylim()` indenfor til at zoome ind på et ønsket område på plottet.

```{r,fig.width=5,fig.height=4}
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width,color = Species)) +
  geom_point() + 
  coord_cartesian(xlim = c(4,6), ylim = c(2.2,4.5)) +
  theme_minimal() 
```

Du kan også zoome ud ved at bruge `expand_limits()`. For eksempel hvis jeg gerne vil have punkterne $x = 0$ og $y = 0$ (`c(0,0)`, eller "origin") med i selve plottet:

```{r,fig.width=5,fig.height=4}
ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width,col=Species)) +
  geom_point() + 
  expand_limits(x = 0, y = 0) +
  theme_minimal() 
```

Det kan være brubart i situationer hvor man, eksempelvis har flere etiketter omkring punkterne i selve plottet, som bedre kan ses hvis man tillader lidt ekstra plads i plottets område.  

### Transformering af akserne - log, sqrt osv (`scale_x_continuous`).

Nogle gange kan det være svært at visualisere nogle variabler på grund af deres fordeling. Er der mange outliers i variablen så er de fleste punkter samlede i et lille område i plottet. Transformering med enten `log` eller `sqrt` på x-aksen og/eller y-aksen er især en populær tilgang, så de data kan ses på en mere informativ måde.

```{r,fig.width=5,fig.height=4}
ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width,col=Species)) +
  geom_point(size=3) + 
  scale_x_continuous(trans = "log2") +
  scale_y_continuous(trans = "log2") +
  theme_minimal() 
```

Man kan også prøve  fk. "sqrt" i stedet for "log2". Formålet er, at hvis de data fordeler sig mere 'normalt', kan man nemmere visualiser det i et plot - en måde til at gøre der er ved at transformere de data med "sqrt" eller "log2".

Bemærk at det er til forskel fra at man transformere selve data som bruges i plottet. Jeg kan for eksempel få samme resultat ved at ændre på datasættet forud for at anvende `ggplot2` - her behøver jeg ikke at bruge `scale_x_continuous(trans = "log2")` for at opnår samme resultat, men notater at tallerne på akserne reflektere de transformeret data og ikke de oprindelige værdier. Den beslutninger man tager her kommer an på, hvad man gerne vil opnå med analysering af de data.

```{r,fig.width=5,fig.height=4}
iris$Sepal.Length <- log2(iris$Sepal.Length)
iris$Sepal.Width <- log2(iris$Sepal.Width)
ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width,col=Species)) +
  geom_point(size=3) +
  theme_minimal() 
```


### Flip coordinates (`coord_flip`)

Vi kan bruge `coord_flip()` til at spejler x-aksen på y-aksen og omvendt (det svarer til, at man drejer plottet ved 90 grader). Se følgende eksempel, hvor jeg først opretter variablen `Sepal.Group`, laver en barplot og anvender `coord_flip` for at få vandrettet søjler.

```{r,fig.width=5, fig.height=3, message=FALSE, warning=FALSE}
#Sepal.Group defineret som i går
iris$Sepal.Group <- ifelse(iris$Sepal.Length>mean(iris$Sepal.Length),"Long","Short")

ggplot(iris,aes(x=Species,fill=Sepal.Group)) + 
  geom_bar(stat="count",position="dodge",color="black") +
  coord_flip() +
  theme_minimal()
```

Man kan ændre på rækkefølgen af de tre `Species` ved at bruge funktionen `scale_x_discrete()` og angiver den nye rækkefølge med indstillingen `limits`:

```{r,fig.width=5, fig.height=3, message=FALSE, warning=FALSE}
ggplot(iris,aes(x=Species,fill=Sepal.Group)) + 
  geom_bar(stat="count",position="dodge",color="black") +
  coord_flip() +
  scale_x_discrete(limits = c("virginica", "versicolor","setosa")) +
  theme_minimal()
```

## Mere om farver og punkt former

Der er flere måder at specificere farver på i `ggplot2`. Man kan nøjes med den automatiske løsning, som er hurtigt (og effektiv i mange situationer), eller man kan bruge den manuelle løsning, som tager lidt mere tid at indkode men er brugbar hvis man gerne vil lave et plot til at præsentere til andre.

### Automatisk farver

Vi så sidste emnet at man automatisk kan bede om forskellige farver, ved at benytte `colour=Species` indenfor `aes()` i den `ggplot()` funktion.

```{r, fig.width=5,fig.height=5}
#automatisk løsning
ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width, colour=Species)) +
  geom_point() +
  theme_minimal() 
```

### Manuelle farver

Hvis man foretrækker at bruge sine egne farver, kan man det ved at benytte funktionen `scale_colour_manual()`. Her angiver jeg stadig `colour=Species` indenfor `aes()` men så angiver jeg hvilke bestemte farver de forskellige arter skal få indenfor `scale_colour_manual` med indstillingen `values`.

```{r, fig.width=5,fig.height=4}
#manuelt løsning
ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width, colour=Species)) +
  scale_colour_manual(values=c("purple", "yellow","pink")) +
  geom_point() +
  theme_minimal() 
```

En faktastisk pakke er `RColorBrewer`. Pakken indeholder mange forskellige "colour palettes", det vil sige grupper af farver, der passer godt med hinanden. Man kan således slippe for at selv samle et godt kombination der passer til plottet. Nogle af de colour palettes tager også i betragtning, eksempelvis hvis man er farveblind, eller om man vil have en farvegradient eller et sæt diskrete farver som ikke ligner hinanden.

I følgende indlæser jeg pakken `RColorBrewer` og anvender funktionen `scale_colour_brewer` med indstillingen `palette="Set1"`:

```{r, fig.width=5,fig.height=4}
#install.packages("RColorBrewer")
library(RColorBrewer)

#manuelt løsning
ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width, colour=Species)) +
  scale_colour_brewer(palette="Set1") +
  geom_point() +
  theme_minimal() 
```

Bemærk at både `scale_color_maual()` og `scale_color_brewer()` sætter farver af punkter og linjer, mens i en boxplot eller barplot sammenhænge, bruger man  `scale_fill_manual()` eller `scale_fill_brewer()`. For eksempel i følgende vil jeg gerne sætte farver på de opfyldte områder i en boxplot: 

```{r, fig.width=5,fig.height=4}
ggplot(iris,aes(x=Species,y=Sepal.Length,fill=Species)) + 
  geom_boxplot() +
  scale_fill_brewer(palette="Set2")  + 
  theme_minimal()
```


Her er en oversigt over de fire funktioner. 

fuktion | beskrivelse
--- | ---
`scale_fill_manual(values=c("firebrick3","blue"))` | manuelle farver til boxplots og barplots osv.
`scale_color_maual(values=c("darkorchid","cyan4"))` | manulle farver til punkter og linjer osv.
`scale_fill_brewer(palette="Dark2")` | `RColourBrewer` løsning til boxplots/barplots/osv.
`scale_color_brewer(palette="Set1")` | `RColourBrewer` løsning til punkter og linjer osv.

Der er også andre muligheder hvis man har behov for dem - for eksempel for kontinuitet data kan man prøve at google efter `scale_fill_gradient`.

***Farver i RColourBrewer***

Her er en nyttig reference, der viser de forskellige farver tilgængelige i pakken `RColourBrewer`.

![Mulige colour palettes tilgængelige i RColourBrewer](plots/rcolorbrewer.png)


### Punkt former

Ligesom man kan lave forskellige farver, kan man også lave forskellige punkt former. Vi starter med den automatiske løsning ligesom vi gjorde med farver. Når det er en variable vi angiver, skal variablenavnet skrives indenfor `aes()`. Her, da `shape` er en parameter som er meget specifik til `geom_point`, vælger jeg at skrive en ny `aes()` indenfor `geom_point()` i stedet for indenfor funktionen `ggplot()`. Husk, at i funktionen `ggplot()` specificerer man globale ting som gælder for hele plot, og i funktionen `geom_pont()` angiver man ting som gælder kun for `geom_point()`. Se følgende eksempel:

```{r,fig.width=5,fig.height=4}
ggplot(data=iris, aes(x = Sepal.Length, y = Sepal.Width)) +
  scale_color_brewer(palette="Set2") +
  geom_point(aes(shape=Species)) + 
  theme_minimal()
```

Så har jeg fået både en farve og en punkt form til hver art i variablen `Species`.

***Sætte punkt form manuelt***

Hvis vi ikke kan lide de tre punkt former vi få automatisk, kan vi ændre dem ved at bruge `scale_shape_manual` - her vælger jeg `values=c(1,2,3)`, men der er en reference nedenunder, hvor I kan se, de mappings mellem de numeriske tal og de punkt former, så at I kan vælger jeres egne.


```{r,fig.width=5,fig.height=4}
ggplot(data=iris, aes(x = Sepal.Length, y = Sepal.Width, colour=Species)) +
  geom_point(aes(shape=Species)) + 
  scale_color_brewer(palette="Set2") +
  scale_shape_manual(values=c(1,2,3)) +
  theme_minimal()
```

***Reference for punkt former***

```{r,fig.width=4,fig.height=4,echo=FALSE,comment=FALSE}
df_shapes <- data.frame(shape = 0:25, shape_name = factor(paste0(0:25)))

ggplot(df_shapes, aes(0, 0, shape = shape)) +
  geom_point(aes(shape = shape), size = 5, fill = 'red', stroke = 2) +
  scale_shape_identity() +
  facet_wrap(~reorder(shape_name, shape)) +
  theme_void()
```

## Annotations (`geom_text`)

### Tilføje labeller direkte på plottet.

Man kan bruge `geom_text()` til at tilføje tekst på punkterne direkte på plottet. Her skal man fortælle, hvad for nogle tekst skal være på plottet - her specificerer vi navne på biler fra datasættet `mtcars`. Plottet er en scatter plot mellem variabler `mpg` og `wt`.

```{r,fig.width=4,fig.height=4}
data(mtcars)

mtcars$my_labels <- row.names(mtcars) #take row names and set as a variable

ggplot(mtcars,aes(x=mpg,y=wt)) + 
  geom_point() +
  geom_text(aes(label=my_labels)) + 
  theme_minimal()
```

For at gøre det nemmere at læse kan man også fjerne selve punkterne:

```{r,fig.width=4,fig.height=4}
ggplot(mtcars,aes(x=mpg,y=wt)) + 
  #geom_point() +
  geom_text(aes(label=my_labels)) + 
  theme_minimal()
```

Teksten på plottet er stadig meget svært at læse. En god løsning kan være at bruge R-pakken `ggrepel`, som i følgende.

### Pakken `ggrepel` for at tilføje tekst labeller

```{r}
#install.packages(ggrepel) #installere hvis nødvendeigt
```

For at anvende pakken `ggrepel` for det `mtcars` datasæt, erstatter man bare `geom_text()` med `geom_text_repel()`: 

```{r,fig.width=4,fig.height=4}
library(ggrepel)
ggplot(mtcars,aes(x=mpg,y=wt)) + 
  geom_point() +
  geom_text_repel(aes(label=my_labels)) + 
  theme_minimal()
```


Så kan vi se, at nu er der ingen navne som sidder lige overfor hinanden, fordi `ggrepel()` har været dygtig nok til at placerer dem tæt på deres tilhørende punkter, og ikke ovenpå hinanden. Man kan også se her, at der er nogle punkter, hvor funktionen har tilføjet en linje for at gøre det klart, hvilken punkt teksten referer til.

I ovenstående har jeg fået en advarsel. Jeg prøver hvad jeg er blevet bedt om - og fortæller, at jeg vil have `max.overlaps = 20`.

```{r}
library(ggrepel)
ggplot(mtcars,aes(x=mpg,y=wt)) + 
  geom_point() +
  geom_text_repel(aes(label=my_labels),max.overlaps = 20) +
  theme_minimal()
```

Så kan du se, at jeg ikke længere få en advarsel, og der tilhører tekst til alle punkterne nu.

### Tilføje rektangler i regioner af interesse (`annotate`)

Hvis man gerne vil fremhæve et bestemt område i plottet, kan man bruge funktionen `annotate()`. Prøve at selv regne ud, hvad de indstillinger indenfor `annotate()` gå ud på i følgende eksempel:

```{r,fig.width=4,fig.height=4}
ggplot(mtcars,aes(x=mpg,y=wt)) + 
  geom_point() +
  geom_text_repel(aes(label=my_labels)) +
  annotate("rect",xmin=18,xmax=23,ymin=2.5,ymax=3,alpha=0.2,fill="orange") +
  theme_minimal()
```

Man kan også benytte den samme funktion til at tilføje nogle tekst på et bestemt sted:

```{r,fig.width=4,fig.height=4}
ggplot(mtcars,aes(x=mpg,y=wt)) + 
  geom_point() +
  geom_text_repel(aes(label=my_labels)) +
  annotate("rect",xmin=18,xmax=23,ymin=2.5,ymax=3,alpha=0.2,fill="orange") +
  annotate("text",x=25,y=2.75,label="Cars of interest",col="orange") + 
  theme_minimal()
```


## Adskille plots med facets (`facet_grid`/`facet_wrap`) 

En stor fordel af at bruge `ggplot` er evnen til at benytte funktionerne `facet_grid()` og `facet_wrap()` til at adskille efter en kategorisk variabel over flere plotter. I følgende kode viser jeg et density plot, hvor de tre kurver der tilhører de tre arter ligger oven på hindanen i det samme plot:

```{r,echo=F}
data(iris)
```


```{r,fig.width=5,fig.height=4}
ggplot(iris,aes(x=Sepal.Length,fill=Species)) + 
  geom_density(alpha=0.5) + 
  theme_minimal()
```

Med funktionen `facet_grid()` eller `facet_wrap()` bruger vi `~` (tilde) tegn til at angive hvordan vi gerne vil visualisere de forskellige plots - skal man opdele dem over rækker (variablerne venstre til `~`) eller over kolonner (variabler højre til `~`)?

```{r,eval=F,echo=T}
#notrun
variable(s) to split into row-wise plots ~ variables(s) to split into column-wise plots
```

Ovenstående density plots af `Sepal.Length` kan adskilles på `Species`, således at man får tre plots med en kolon til hver af de tre arter:

```{r,fig.width=5,fig.height=4}
ggplot(iris,aes(x=Sepal.Length,fill=Species)) + 
  geom_density(alpha=0.5) + 
  facet_grid(~Species) + #split Species into different column-wise plots
  theme_minimal()
```

Man kan gøre det over rækkerne (man skal dog husk at bruge en "." efter "~" for at betegne at man kun vil adskille plots over rækkerne, mens kan af en eller anden grund kan man dropper "." hvis man kun vil adskiller over kolonner som i ovenstående).

```{r,fig.width=5,fig.height=4}
ggplot(iris,aes(x=Sepal.Length,fill=Species)) + 
  geom_density(alpha=0.5) + 
  facet_grid(Species~.) + #split Species into different column-wise plots
  theme_minimal()
```

Her angives `Sepal.Group~Species`, der betyder, at plotterne bliver adskilt efter både `Sepal.Group` og `Species` - `Sepal.Group` over rækkerne, og `Species` over kolonnerne:

```{r,echo=F}
iris$Sepal.Group <- ifelse(iris$Sepal.Length > mean(iris$Sepal.Length), "Long", "Short")
iris$Sepal.Group <- as.factor(iris$Sepal.Group)
```


```{r,fig.width=5,fig.height=4}
ggplot(iris,aes(x=Sepal.Length,fill=Species)) + 
  geom_density(alpha=0.5) + 
  facet_grid(Sepal.Group~Species) + #split Species into different column-wise plots
  theme_minimal()
```


Bemærk forskellen mellem `facet_grid()` og `facet_wrap()`:

```{r,fig.width=5,fig.height=4}
#same plot, replace facet_grid with facet_wrap
ggplot(iris,aes(x=Sepal.Length,fill=Species)) + 
  geom_density(alpha=0.5) + 
  facet_wrap(Sepal.Group~Species) + 
  theme_minimal()
```

I `facet_grid()` bliver man tvunget til at få en "grid" layout. Vi har således 6 plotter i en 2 x 3 grid (2 niveauer til variablen `Sepal.Group` og 3 niveauer til variablen `Species`), og det sker selvom den ene af dem har ikke noget data ind i - der findes altså ikke nogle observationer hvor `Species` er "Setosa" og `Sepal.Group` er "Long", men vi får et plot alligevel for at bevare strukturen. Med `facet_wrap()` bliver plotterne uden data droppet og i dette tilfælde får man 5 plotter i hvad der kaldes for en "ribbon".

Med `facet_wrap()` kan man også fortælle at vi gerne vil have plotterne over 1 row (`nrow = 1` eller `ncol = 5`):
```{r,fig.width=6.5,fig.height=3.5}
ggplot(iris,aes(x=Sepal.Length,fill=Species)) + 
  geom_density(alpha=0.5) + 
  facet_wrap(Sepal.Group~Species,nrow = 1) + 
  theme_minimal()
```

Til sidste kan det være at jeg gerne vil "befrie" skalen på y-akserne - på den måde har ikke alle plotter den samme maksimum y-værdi og de enkelte plotter benytter i stedet egne værdierne til at bestemme skalerne. Det kan være brugbart hvis man inddrager forskellige målinger men vær dog opmærksom på vhad der bedste giver mening - hvis man direkte vil sammenligne to af plotterne så er det bedre at de dele samme y-akse skale.

```{r,fig.width=6.5,fig.height=3.5}
#same plot, replace facet_grid with facet_wrap
ggplot(iris,aes(x=Sepal.Length,fill=Species)) + 
  geom_density(alpha=0.5) + 
  facet_wrap(Sepal.Group~Species,ncol = 5,scales = "free") + 
  theme_minimal()
```

Jeg håber at det er klart, at funktionerne er meget brugbart, og mens de opnår stort set samme ting, er der små forskel mellem dem, der er værd at husk.

## Gemme dit plot

Her bruger vi R Markdown til at lave et rapport som indeholder vores plots, men det også kan være at man gerne vil gemme sit plot som fil på computeren. Til at gemme et plot kan man bruge kommandoen `ggsave()`:

```{r, eval=FALSE}
ggsave(myplot, "myplot.pdf")
```

Figuren vil blive gemt i din _working directory_ (eller den mappe, du har din .Rmd fil). Filtypen `.pdf` kan erstattes med andre formater, for eksempel `.png` eller `jpeg` osv. Hvis man gerne vil tage sit plot og redigerer på det (fk. Adobe Illustrater eller Inkscape), vil jeg anbefaler, at du bruge `.pdf`.

Man må gerne ændre højden og bredden på det gemt plot med  `width` og `height`:

```{r, eval=FALSE}
ggsave(myplot, "myplot.pdf", width = 4, height = 4)
```


## Problemstillinger

__Problem 1__) Lav quiz - "Quiz - ggplot2 part 2"

- - -

__Problem 2__) (*Factorer og plots*)
 
 __a__) Åbn datsættet `mtcars` og lav en barplot:
 
  <!-- * Først tjek hvor mange unikke værdier er der i variablen `cyl`. -->
  
  * Bruge variablen `cyl` på x-aksen og give forskellige farver efter den samme variabel.
  * Virker din kode? Kig på x-aksen.
  * Variablen er numerisk men skal fortolkes som en factor. Lav variablen om til en factor (eller bare skriv `as.factor(cyl)` i selve plottet) og lave dit plot igen. 

```{r,echo=FALSE,eval=F}
data(mtcars)
ggplot(data = mtcars, aes(x = cyl,fill = cyl)) +
  geom_bar(stat="count") + theme_minimal()
```

```{r,echo=FALSE,eval=F}
mtcars$cyl <- as.factor(mtcars$cyl)
ggplot(data = mtcars, aes(x = cyl,fill = cyl)) +
  geom_bar(stat="count") + theme_minimal()
```

  __b__) Opdel søjlerne ved at angive farver efter variablen `gear` i dit plot (søjlerne skal sidde ved siden af hinanden). Vær OBS om hvordan R fortolker variablen. 

```{r,echo=F,eval=F}
ggplot(data = mtcars, aes(x = cyl,fill = as.factor(gear))) +
  geom_bar(stat="count",position="dodge") + 
  theme_minimal()
```

- - -

I følgende problemer arbejder vi med datasættet `Palmer Penguins`. Pakken `palmerpenguins` skal installeres hvis du ikke har brugt datasættet før.

Data beskrivelse: *The palmerpenguins data contains size measurements for three penguin species observed on three islands in the Palmer Archipelago, Antarctica.*

```{r, echo=FALSE,comment=FALSE,warning=FALSE,out.width="20%"}
# Bigger fig.width
library(png)
include_graphics("plots/palmerpenguins.png")
```

```{r,comment=FALSE,warning=FALSE,message=FALSE}
#install.packages("palmerpenguins") #køre hvis ikke allerede installeret
library(palmerpenguins)
library(ggplot2)
library(tidyverse)
head(penguins)
```

Man kan altid anvende `?penguins` for at se flere detaljer om variablenavner.

*Vi skal starte med at rydde op lidt i datasættet. Køre følgende for at fjerne al rækker som har NA (manglende) værdier:*

```{r}
penguins <- drop_na(penguins)
```

- - -

__Problem 3__) *Manuelt farver og punkter* 

__a__) Lav en scatter plot med `ggplot`: 

* `bill_length_mm` på x-aksen
* `bill_depth_mm` på y-aksen 
*  give hver `species` sin egen farve (automatisk løsning)
*  sætte et tema

```{r,echo=FALSE,fig.width=4,fig.height=3.5,fig.cap="Min løsning",eval=FALSE}
ggplot(data=penguins,aes(x=bill_length_mm,y=bill_depth_mm,color=species)) +
  geom_point() +
  xlab("Bill length (mm") + ylab("Bill depth (mm)") +
  ggtitle("Scatter plot for penguin data") +
  theme_minimal()
```

__b__) Lav følgende ændringer til det plot:

* Ændr farver manuelt - prøv både at angive farver med `scale_color_manual` og afprøve også løsningen med pakken `RColorBrewer` (husk at installere/indlæse pakken hvis nødvendigt).
* Angiv at der skal være forskellige punkt former for hver art i variablen `species`.
* Prøv også at vælge nogle punkt former fra listen og specificer dem manuelt.

```{r,echo=FALSE,fig.width=4,fig.height=3.5,fig.cap="Min løsning"}
ggplot(data=penguins,aes(x=bill_length_mm,y=bill_depth_mm,color=species)) +
  geom_point(aes(shape=species)) +
  scale_color_brewer(palette = "Accent") + 
  xlab("Bill length (mm") + ylab("Bill depth (mm)") +
  ggtitle("Scatter plot for penguin data") +
  theme_minimal()
```

- - -

__Problem 4__) *Coordinate systemer* 

Tag overstående scatter plot fra __3__) og 

__a__) brug `coord_cartesian()` så at man fanger kun en bill længde (variablen `bill_length_mm`) mellem 40 og 50, og en bill depth (variablen `bill_depth_mm`) mellem 16 og 19.  
__b__) brug pakken `ggrepel` (husk at installere/inlæse) og tilføj navnerne af de forskellige øer som tekst direkte på plottet 
__c__) lav en delmængde af dataframen `penguins` efter samme kriterier som __a__) og specificer din nye dataframe som parameteren `data` indenfor  `geom_text_repel`-funktionen. Det undgår, at tekst bliver plottet for punkterne udenfor området angivet med `coord_cartesian()`). 

```{r,echo=FALSE,fig.width=5,fig.height=4,fig.cap="Min løsning"}
peng_subset <- subset(penguins,bill_depth_mm >16 & bill_depth_mm<19 & bill_length_mm>40 & bill_length_mm<50)

ggplot(data=penguins,aes(x=bill_length_mm,y=bill_depth_mm,color=species)) +
  geom_point(aes(shape=species)) +
  coord_cartesian(ylim = c(16,19) , xlim = c(40,50)) +
  scale_color_brewer(palette = "Accent") + 
  geom_text_repel(data=peng_subset,aes(label=island)) +
  xlab("Bill length (mm") + ylab("Bill depth (mm)") +
  ggtitle("Scatter plot for penguin data") +
  theme_minimal()
```
- - -

__Problem 5__) *Histogram med facets*

Lav en histogram:

* Variablen `flipper_length_mm` på x-aksen
* Anvend `facet_grid` for at adskille dit plot i tre efter variablen `species`
* Giv også en forskellige farve til hver art i `species`
* Hvis nødvendigt ændr parameteren `bins` til noget andet indenfor `geom_histogram()`.

Her er min løsning:

```{r,echo=TRUE,eval=TRUE,fig.width=6,fig.height=4}
ggplot(data=penguins,aes(x=flipper_length_mm,fill=species)) +
  geom_histogram(bins = 30, alpha=0.5, colour="black") +
  scale_fill_brewer(palette = "Set1") +
  ggtitle("Histogram of flipper length according to species") +
  facet_grid(~species) +
  xlab("Flipper length (mm)") +
  theme_minimal()
```

- - -

__Problem 6__) __a)__ Lave et density plot af `body_mass_g`.

* Anvend funktionen `facet_grid` til at opdele i til tre plots efter `species`
* Brug også `fill` til at opdele densities indenfor de tre plots efter variablen `sex`
* Gør dine density plots gennemsigtige
* Skrive en sætning om forskellen i `body_mass_g` mellem "females" og "males".

<!-- * Hvorfor tror du, at de densities har flere topper? -->

```{r,echo=FALSE,eval=FALSE,fig.width=4,fig.height=3}
ggplot(data=penguins,aes(x=body_mass_g,fill=sex)) +
  geom_density(alpha=0.5) +
  facet_grid(~species) +
  xlab("Body mass (g)") + ylab("Density") + 
  ggtitle("Density plots according to sex") +
  theme_minimal()
```

__b__) Nu udvikl din `facet_grid` kommando til at adskille plots yderligere således at du har en "grid" struktur med de forskellige øer (variablen `island`) på rækkerne og de tre arter (variablen `spieces`) på kolonnerne.

```{r,echo=FALSE,eval=FALSE,fig.width=4,fig.height=3}
ggplot(data=penguins,aes(x=body_mass_g,fill=sex)) +
  geom_density(alpha=0.5) +
  facet_grid(island~species) +
  xlab("Body mass (g)") + ylab("Density") + 
  ggtitle("Density plots according to sex") +
  theme_minimal()
```

__c__) Kan du forklare hvorfor der er blank plotter i din grid? Eksperimenter med `facet_wrap` i stedet for `facet_grid`. 

```{r,echo=FALSE,eval=FALSE,fig.width=4,fig.height=3}
ggplot(data=penguins,aes(x=body_mass_g,fill=sex)) +
  geom_density(alpha=0.5) +
  facet_wrap(island ~ sepecies) +
  xlab("Body mass (g)") + ylab("Density") + 
  ggtitle("Density plots according to sex") +
  theme_minimal()
```

<!-- __b)__ Vi vil gerne adskille vores densities yderligere, efter `species`. -->

<!-- * Nu tilføj linjen `facet_grid(~species)` til dit plot og opdag, hvad der sker.  -->
<!-- * Skriv endnu en sætning, som beskriver forskellen i `body_mass_g` mellem de to køn over de tre `species`. -->

<!-- ```{r,echo=FALSE,eval=FALSE} -->
<!-- ggplot(data=penguins,aes(x=body_mass_g,fill=sex)) + -->
<!--   geom_density(alpha=0.5) + -->
<!--   facet_grid(~species) + -->
<!--   theme_minimal() -->
<!-- ``` -->

- - -

__Problem 7__) *Coordinate systemer* 

Lav en barplot af counts for `species` opdelte efter `sex`. 

* Anvend en 'coordinate flip' for at få den til at være vandrette/horizontal.
* Vælg nogle farver - jeg benytter `palette = "Accent"` fra den `RColorBrewer` løsning


```{r,echo=FALSE,eval=F,fig.width=4.5,fig.height=2.5,fig.cap="Min løsning"}
#Løsning
ggplot(data=penguins,aes(x=species,fill=sex)) +
  geom_bar(stat="count",position="dodge") + 
  coord_flip() + 
  scale_fill_brewer(palette = "Accent") +
  theme_minimal()
```

* Ændr rækkefølgen af de tre søjler, således at arten med de meste observationer er på toppen og arten med den færrest er på bunden.
* Prøv også `scale_y_reverse()` og kig på resultatet.

Her er min løsning
```{r,echo=FALSE,fig.width=5,fig.height=3,eval=TRUE,fig.cap="Min løsning"}
#Løsning
ggplot(data=penguins,aes(x=species,fill=sex)) +
  geom_bar(stat="count",position="dodge") + 
  coord_flip() + 
  scale_fill_brewer(palette = "Accent") +
  scale_x_discrete(limits = rev(c("Adelie", "Gentoo","Chinstrap"))) + 
  theme_minimal()
```

- - -

__Problem 8__) Lav boxplots af `body_mass_g` opdelt efter `species`.

* Tilføj "jitter" punkter ovenpå boxplots.
* Specificer nogle farver manuelt for både boxes og punkterne (en farve til hver art)
* Giv det en hensigtsmæssig titel og nogle akser-labels
* Tilføj en ny variabel `island_binary` til `penguins`, som er "Biscoe" hvis `island` er 'Biscoe' og "not Biscoe" hvis ikke.
* Adskille plotterne ved at opdele efter `island_binary`.

```{r,echo=FALSE,eval=FALSE,fig.width=5,fig.height=4,fig.cap="Min løsning"}
#Løsning
penguins$island_binary <- ifelse(penguins$island=="Biscoe","Biscoe","not Biscoe")

ggplot(data = penguins, aes(x=species,y=body_mass_g,fill=species,colour=species)) +
  geom_boxplot(show.legend = FALSE,alpha=0.25) +
  geom_jitter(alpha=0.75,show.legend = FALSE) +
  scale_colour_brewer(palette = "Set2") + 
  scale_fill_brewer(palette = "Set2") + 
  facet_grid(~island_binary) +
  theme_classic()
```


* Ekstra: prøv `?geom_violin` som erstatning for `geom_boxplot`.

- - -

__Problem 9__) *Annotations og linjer*. 

__a__) Lav et scatter plot af `bill_length_mm` vs `bill_depth_mm`.

* Anvend hensigtsmæssigt titel/labels/tema
* Anvend forskellige farver for de tre `species`.
* Tjek funktionen `?annotate` og bruge den med `geom="text"` og hensigtsmæssigt x- og y-akse værdier til at tilføje `species` navne som tekst direkte på plottet (se eksempel nedenfor for at se, hvad jeg mener).
* Udforsk hvordan man gøre teksten større, som jeg har gjort i min løsning.
* Fjern legend med `show.legend = FALSE` indenfor `geom_point()`

<!-- * Ekstra: bruge `annotate` igen til at lave et orange rektangel omkring alle de blå punkter (se kursusnotaterne). -->

Her er min løsning:

```{r,echo=FALSE,fig.width=4,fig.height=4}
ggplot(penguins,aes(x=bill_length_mm,y=bill_depth_mm,colour=species)) +
  geom_point(show.legend = FALSE) +
  annotate("text",40,20,label="Adelie",size=8) +
  annotate("text",55,19,label="Chinstrap",size=8) +
  annotate("text",45,15,label="Gentoo",size=8) +
  xlab("Bill length (mm)") + ylab("Bill depth (mm)") + 
  theme_minimal()
```



__b__) Vi vil gerne tilføje nogle lodrette og vandrette linjer til plottet, som viser middelværdierne af variablerne for de tre arter

* Først brug `tapply` til at beregne de gennemsnitlige værdier for henholdsvis `bill_length_mm` og `bill_depth_mm` opdelte efter `species` (gem dem som henholdsvis `mean_length` og `mean_depth`)
* Brug `mean_length` og `mean_depth` til at tilføje linjer til plottet med den relevante funktion.

```{r,echo=F}
mean_length <- tapply(penguins$bill_length_mm,penguins$species,mean)
mean_depth <- tapply(penguins$bill_depth_mm,penguins$species,mean)
```


__c__) **Udfordring** Kan du gøre linjerne til samme farver som punkterne af deres pågældende art (se min løsning nedenunder)?

* Hint: tage udgangspunkt i følgende dataframe, der bruger din beregnede værdier:

```{r,echo=TRUE}
mydf <- data.frame("species"=names(mean_length),"mlength"=mean_length,"mdepth"=mean_depth)
mydf
```

* Angiv parameteren `data` til at være ovenstående dataframe i `geom_vline()` og brug lokal aethestiks (`aes()`) til at angive parametre til linjerne.
* Gør samme for `geom_hline()`
* Specificer også "dashed" linjer

Her er min løsning:

```{r,fig.width=5,fig.height=5,echo=FALSE,fig.cap="min løsning"}
ggplot(penguins,aes(x=bill_length_mm,y=bill_depth_mm,colour=species)) +
  geom_point(show.legend = FALSE) + 
  geom_vline(data=mydf,show.legend = FALSE,aes(xintercept=mlength,colour=species),lty=2) +
  #geom_hline(data=mydf,show.legend = FALSE,aes(yintercept=mdepth,colour=species),lty=2) +
  #geom_vline(xintercept =mean_length,show.legend = FALSE,aes(colour=species),lty=2) +
  geom_hline(data=mydf,show.legend = FALSE,aes(yintercept=mdepth,colour=species),lty=2) +
  annotate("text",40,20,label="Adelie",size=8) +
  annotate("text",55,19,label="Chinstrap",size=8) +
  annotate("text",45,15,label="Gentoo",size=8) +
  xlab("Bill length (mm)") + ylab("Bill depth (mm)") + 
  theme_minimal()
```

- - -

__Problem 10__) *Ekstra*. Kig på "cheatsheet" til ggplot2 (Tryk på "Help" > "Cheatsheets" og vælg en til ggplot2) og afprøve nogle af de ting, som ikke var dækket i kurset indtil videre! Gerne lad mig høre hvis du synes der er eventuelle noget meget nyttig for dig, som er ellers blevet glemt i notaterne.


## Ekstra links

R Graphics cookbook

https://r-graphics.org/

